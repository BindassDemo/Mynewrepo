package com.aspectsecurity.contrast.contrastjenkins;

import com.contrastsecurity.exceptions.UnauthorizedException;
import com.contrastsecurity.http.TraceFilterForm;
import com.contrastsecurity.models.Application;
import com.contrastsecurity.models.Organizations;
import com.contrastsecurity.models.SecurityCheck;
import com.contrastsecurity.models.Trace;
import com.contrastsecurity.models.Traces;
import com.contrastsecurity.sdk.ContrastSDK;
import hudson.AbortException;
import hudson.EnvVars;
import hudson.Extension;
import hudson.Launcher;
import hudson.model.AbstractBuild;
import hudson.model.AbstractProject;
import hudson.model.Action;
import hudson.model.BuildListener;
import hudson.model.Result;
import hudson.tasks.BuildStepDescriptor;
import hudson.tasks.BuildStepMonitor;
import hudson.tasks.Publisher;
import hudson.tasks.Recorder;
import hudson.util.ListBoxModel;
import jenkins.model.Jenkins;
import lombok.Getter;
import lombok.Setter;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.bind.JavaScriptMethod;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;


/**
 * Vulnerability Trend Builder
 * <p>
 * Checks the number of vulnerabilities in the application against the configured threshold.
 */
@Getter
@Setter
public class VulnerabilityTrendRecorder extends Recorder {

    private List<ThresholdCondition> conditions;
    private String teamServerProfileName;
    private boolean overrideGlobalThresholdConditions;
    private int queryBy;


    @DataBoundConstructor
    public VulnerabilityTrendRecorder(List<ThresholdCondition> conditions, String teamServerProfileName, boolean overrideGlobalThresholdConditions, int queryBy) {
        this.conditions = conditions;
        this.teamServerProfileName = teamServerProfileName;
        this.overrideGlobalThresholdConditions = overrideGlobalThresholdConditions;
        this.queryBy = queryBy;
    }

    protected Object readResolve() {

        Jenkins jenkins = Jenkins.getInstance();
        if (jenkins != null) {
            ContrastPluginConfig.ContrastPluginConfigDescriptor contrastPluginConfigDescriptor = jenkins.getDescriptorByType(ContrastPluginConfig.ContrastPluginConfigDescriptor.class);

            final TeamServerProfile[] profiles = contrastPluginConfigDescriptor.getTeamServerProfiles();
            for (TeamServerProfile profile : profiles) {
                if (profile.getApps() == null) {
                    ContrastSDK contrastSDK = VulnerabilityTrendHelper.createSDK(profile.getUsername(), profile.getServiceKey(),
                            profile.getApiKey(), profile.getTeamServerUrl());
                    List<App> apps = VulnerabilityTrendHelper.saveApplicationIds(contrastSDK, profile.getOrgUuid());
                    profile.setApps(apps);
                    profile.setFailOnWrongApplicationId(profile.isFailOnWrongApplicationName());

                    contrastPluginConfigDescriptor.save();
                }
            }

            for (ThresholdCondition thresholdCondition : conditions) {
                if (thresholdCondition.getApplicationId() == null && thresholdCondition.getApplicationName() != null) {
                    TeamServerProfile profile = VulnerabilityTrendHelper.getProfile(teamServerProfileName);
                    for (App app : profile.getApps()) {
                        String subStr = app.getTitle().substring(0, app.getTitle().lastIndexOf(" ("));
                        if (subStr.equals(thresholdCondition.getApplicationName())) {
                            thresholdCondition.setApplicationId(app.getName());
                            break;
                        }
                    }
                }
            }
        }
        return this;
    }

    private TraceFilterForm buildFilterFormForCondition(final ThresholdCondition condition, final AbstractBuild<?, ?> build, final String appId, final BuildListener listener) throws IOException, InterruptedException {
        TraceFilterForm filterForm = new TraceFilterForm();

        if (queryBy == Constants.QUERY_BY_APP_VERSION_TAG_HIERARCHICAL_FORMAT) {
            String appVersionTag = VulnerabilityTrendHelper.buildAppVersionTagHierarchical(build, appId);

            List<String> appVersionTagsList = new ArrayList<>();
            appVersionTagsList.add(appVersionTag);

            if (condition.getApplicationName() != null) {
                String appVersionTagAppName = VulnerabilityTrendHelper.buildAppVersionTagHierarchical(build, condition.getApplicationName());
                appVersionTagsList.add(appVersionTagAppName);
            }

            filterForm.setAppVersionTags(appVersionTagsList);
        } else if (queryBy == Constants.QUERY_BY_START_DATE) {
            filterForm.setStartDate(new Date(build.getStartTimeInMillis()));
        } else if (queryBy == Constants.QUERY_BY_PARAMETER) {
            final EnvVars env = build.getEnvironment(listener);
            String appVersionTag;

            if (env.get("APPVERSIONTAG") != null) {
                appVersionTag = env.get("APPVERSIONTAG");
            } else {
                appVersionTag = "";
            }

            if (appVersionTag.isEmpty()) {
                VulnerabilityTrendHelper.logMessage(listener, "Warning: queryBy Parameter is configured, but APPVERSIONTAG is not set. All vulnerabilities will be returned for this application");
            }

            List<String> appVersionTagsList = new ArrayList<>();
            appVersionTagsList.add(appVersionTag);

            filterForm.setAppVersionTags(appVersionTagsList);
        } else {
            String appVersionTag = VulnerabilityTrendHelper.buildAppVersionTag(build, appId);

            List<String> appVersionTagsList = new ArrayList<>();
            appVersionTagsList.add(appVersionTag);

            if (condition.getApplicationName() != null) {
                String appVersionTagAppName = VulnerabilityTrendHelper.buildAppVersionTag(build, condition.getApplicationName());
                appVersionTagsList.add(appVersionTagAppName);
            }

            filterForm.setAppVersionTags(appVersionTagsList);
        }

        if (condition.getThresholdSeverity() != null) {
            filterForm.setSeverities(VulnerabilityTrendHelper.getSeverityList(condition.getThresholdSeverity()));
        }

        if (condition.getThresholdVulnType() != null) {
            filterForm.setVulnTypes(Collections.singletonList(condition.getThresholdVulnType()));
        }

        if (!condition.getVulnerabilityStatuses().isEmpty()) {
            filterForm.setStatus(condition.getVulnerabilityStatuses());
        }
        return filterForm;
    }

    /**
     * Set the build result based on contrast configuration
     * @param build build object
     * @param profile teamserver profile
     * @param message Message to log when status is failure
     * @return true = the result was set, false = the result was not set
     */
    private boolean updateBuildResult(AbstractBuild<?, ?> build, TeamServerProfile profile, String message) throws AbortException {
        if(profile.isApplyVulnerableBuildResultOnContrastError()) {
            Result profileVulnerableBuildResult = Result.fromString(profile.getVulnerableBuildResult());
            if(Result.FAILURE.equals(profileVulnerableBuildResult)) {
                throw new AbortException(message);
            } else {
                build.setResult(profileVulnerableBuildResult);
                return true;
            }
        }
        return false;
    }

    @Override
    public boolean perform(AbstractBuild<?, ?> build, Launcher launcher, final BuildListener listener) throws IOException, InterruptedException {

        if (!build.isBuilding()) {
            return false;
        }

        VulnerabilityTrendHelper.logMessage(listener, "Checking the number of vulnerabilities for this application.");
        ContrastSDK contrastSDK;
        Traces traces;
        Set<Trace> resultTraces = new HashSet<>();

        TeamServerProfile profile = VulnerabilityTrendHelper.getProfile(teamServerProfileName);
        if(profile == null) {
            throw new AbortException("Unable to find TeamServer profile.");
        }

        final String CONTRAST_ERROR_PREFIX = profile.isApplyVulnerableBuildResultOnContrastError() ? "Error: " : "Warning: ";

        contrastSDK = VulnerabilityTrendHelper.createSDK(profile.getUsername(), profile.getServiceKey(), profile.getApiKey(), profile.getTeamServerUrl());

        try {
            final Organizations organizations = contrastSDK.getProfileDefaultOrganizations();
            if (organizations == null || organizations.getOrganization() == null) {
                String errorMessage = CONTRAST_ERROR_PREFIX + "No organization found, Check your credentials and URL.";
                VulnerabilityTrendHelper.logMessage(listener, errorMessage);
                updateBuildResult(build, profile, errorMessage);
                return true;
            }

        } catch (UnauthorizedException | IOException e) {
            String errorMessage = CONTRAST_ERROR_PREFIX + "Unable to connect to Contrast.";
            VulnerabilityTrendHelper.logMessage(listener, errorMessage);
            VulnerabilityTrendHelper.logMessage(listener, e.getMessage());
            updateBuildResult(build, profile, errorMessage);
            return true;
        }

        boolean ignoreContrastFindings = Boolean.parseBoolean(build.getBuildVariableResolver().resolve("ignoreContrastFindings"));

        List<GlobalThresholdCondition> globalThresholdConditions = VulnerabilityTrendHelper.getGlobalThresholdConditions(profile.getName());

        List<ThresholdCondition> thresholdConditions = conditions;

        // iterate over conditions; fail on first
        for (ThresholdCondition condition : thresholdConditions) {


            String appId = condition.getApplicationId();
            MatchBy matchBy = condition.getMatchBy() == null ? MatchBy.APPLICATION_ID : condition.getMatchBy();
            switch(matchBy){
                case APPLICATION_ORIGIN_NAME:
                    try {
                        Application app = contrastSDK.getApplicationByNameAndLanguage(profile.getOrgUuid(), condition.getApplicationOriginName(), VulnerabilityTrendHelper.getAgentTypeFromString(condition.getAgentType()));

                        if (app == null) {
                            String errorMessage = String.format(CONTRAST_ERROR_PREFIX + "Application with [name = %s, agentType = %s] not found.", condition.getApplicationOriginName(), condition.getAgentType());
                            VulnerabilityTrendHelper.logMessage(listener, errorMessage);

                            if (condition.isFailOnAppNotFound()) {
                                throw new AbortException(errorMessage);
                            }

                            if(updateBuildResult(build, profile, errorMessage)) {
                                return true;
                            } else {
                                continue;
                            }
                        } else {
                            condition.setApplicationId(app.getId());
                            appId = condition.getApplicationId();
                            VulnerabilityTrendHelper.logMessage(listener, "Fetched Application : [name = '" + condition.getApplicationOriginName() + "', displayName = '" + app.getName() + "', agentType='" + app.getLanguage() + "'] with ID: [" + appId + "]");
                        }
                    } catch (UnauthorizedException e) {
                        String errorMessage = CONTRAST_ERROR_PREFIX + "Unable to retrieve application information from TeamServer.";
                        VulnerabilityTrendHelper.logMessage(listener, errorMessage);
                        VulnerabilityTrendHelper.logMessage(listener, e.getMessage());
                        if(updateBuildResult(build, profile, errorMessage)) {
                            return true;
                        } else {
                            continue;
                        }
                    }
                    break;
                case APPLICATION_ID:
                default:
                    if (VulnerabilityTrendHelper.getAppIdFromAppTitle(appId) != null) {
                        appId = VulnerabilityTrendHelper.getAppIdFromAppTitle(appId);
                    }
                    break;
            }

            boolean applicationIdExists = VulnerabilityTrendHelper.applicationIdExists(contrastSDK, profile.getOrgUuid(), appId);
            if (!applicationIdExists) {
                String errorMessage = CONTRAST_ERROR_PREFIX + "Application with ID '" + appId + "' not found.";
                VulnerabilityTrendHelper.logMessage(listener, CONTRAST_ERROR_PREFIX + "Application with ID '" + appId + "' not found.");
                if(updateBuildResult(build, profile, errorMessage)) {
                    return true;
                } else {
                    continue;
                }
            } else {

                try {

                    TraceFilterForm filterForm = buildFilterFormForCondition(condition, build, appId, listener);
                    SecurityCheck securityCheck = VulnerabilityTrendHelper.makeSecurityCheck(contrastSDK, profile.getOrgUuid(), appId, build.getTimeInMillis(), queryBy, filterForm);

                    if(securityCheck.getResult() != null) {
                        String applicationDisplayForConsoleOutput = condition.getStringForOverriden();
                        VulnerabilityTrendHelper.logMessage(listener, "Checking application " + applicationDisplayForConsoleOutput);
                        VulnerabilityTrendHelper.logMessage(listener,"Your Contrast admin has overridden policies you may have set in Vulnerability Security Controls or the 'query by' parameter");

                        if(securityCheck.getResult()) { //failed a policy
                            VulnerabilityTrendHelper.logMessage(listener, "This application did not violate any Contrast policies");
                            return true;
                        } else {
                            try {
                                Result jobResult = VulnerabilityTrendHelper.getJenkinsResultFromJobOutcome(securityCheck.getJobOutcomePolicy().getOutcome());
                                String message = "This application "+applicationDisplayForConsoleOutput+" violated the Contrast policy '"+securityCheck.getJobOutcomePolicy().getName()+"'";
                                VulnerabilityTrendHelper.logMessage(listener,message);
                                if(Result.FAILURE.equals(jobResult)) {
                                    throw new AbortException(message);
                                } else {
                                    build.setResult(jobResult);
                                    return true;
                                }
                            } catch (VulnerabilityTrendHelperException e) {
                                String errorMessage = CONTRAST_ERROR_PREFIX + "Unable to retrieve outcome from job outcome policy";
                                VulnerabilityTrendHelper.logMessage(listener, errorMessage);
                                VulnerabilityTrendHelper.logMessage(listener, e.getMessage());
                                if(updateBuildResult(build, profile, errorMessage)) {
                                    return true;
                                } else {
                                    continue;
                                }
                            }
                        }
                    } else {

                        // if global threshold conditions cannot be overridden or the user does not want to override them
                        if (!profile.isAllowGlobalThresholdConditionsOverride() || !overrideGlobalThresholdConditions) {
                            thresholdConditions = VulnerabilityTrendHelper.getThresholdConditions(conditions, globalThresholdConditions);
                            if (thresholdConditions.isEmpty()) {
                                String errorMessage = CONTRAST_ERROR_PREFIX + "Global Contrast Vulnerability Threshold Conditions for profile '" + profile.getName() + "' are not defined.";
                                VulnerabilityTrendHelper.logMessage(listener, errorMessage);
                                if(updateBuildResult(build, profile, errorMessage)) {
                                    return true;
                                } else {
                                    continue;
                                }
                            }
                        }

                        VulnerabilityTrendHelper.logMessage(listener, "filterForm: " + filterForm);
                        VulnerabilityTrendHelper.logMessage(listener, "Checking the threshold condition where " + condition.toString());
                        if (queryBy == Constants.QUERY_BY_START_DATE || queryBy == Constants.QUERY_BY_PARAMETER) {
                            traces = VulnerabilityTrendHelper.getAllTraces(contrastSDK, profile.getOrgUuid(), appId, filterForm);
                        } else {
                            traces = VulnerabilityTrendHelper.getAllTraces(contrastSDK, profile.getOrgUuid(), null, filterForm);
                        }
                        resultTraces.addAll(traces.getTraces());
                        int thresholdCount = condition.getThresholdCount(); // Integer.parseInt(condition.getThresholdCount());

                        if (traces.getCount() > thresholdCount && !ignoreContrastFindings) {
                            // save results before failing build
                            buildResult(resultTraces, build);

                            Result buildResult = Result.fromString(profile.getVulnerableBuildResult());
                            VulnerabilityTrendHelper.logMessage(listener, "Failed on the threshold condition where " + condition.toString());
                            VulnerabilityTrendHelper.logMessage(listener, VulnerabilityTrendHelper.getVulnerabilityInfoString(traces));
                            if (buildResult.toString().equals(Result.FAILURE.toString())) {
                                throw new AbortException("Failed on the threshold condition where " + condition.toString());
                            } else {
                                build.setResult(buildResult);
                                return true;
                            }
                        }
                    }
                } catch (UnauthorizedException e) {
                    String errorMessage = CONTRAST_ERROR_PREFIX + "Unable to retrieve vulnerability information from TeamServer.";
                    VulnerabilityTrendHelper.logMessage(listener, errorMessage);
                    VulnerabilityTrendHelper.logMessage(listener, e.getMessage());
                    if(updateBuildResult(build, profile, errorMessage)) {
                        return true;
                    } else {
                        continue;
                    }

                }
            }
        }


        buildResult(resultTraces, build);

        VulnerabilityTrendHelper.logMessage(listener, "This build passes all vulnerability threshold conditions!");

        return true;

    }

    @Override
    public DescriptorImpl getDescriptor() {
        return (DescriptorImpl) super.getDescriptor();
    }

    @Override
    public BuildStepMonitor getRequiredMonitorService() {
        return BuildStepMonitor.NONE;
    }

    @Override
    public Action getProjectAction(AbstractProject<?, ?> project) {
        return new VulnerabilityTrendProjectAction(project);
    }


    /**
     * Descriptor for {@link VulnerabilityTrendRecorder}.
     */
    @Extension
    public static class DescriptorImpl extends BuildStepDescriptor<Publisher> {

        private List<ThresholdCondition> conditions;
        private String teamServerProfileName;
        private Boolean overrideGlobalThresholdConditions;
        private Integer queryBy;

        public DescriptorImpl() {
            super(VulnerabilityTrendRecorder.class);
            load();
        }

        @JavaScriptMethod
        public boolean isAllowGlobalThresholdConditionsOverride(String teamServerProfileName) {
            return VulnerabilityTrendHelper.getProfile(teamServerProfileName).isAllowGlobalThresholdConditionsOverride();
        }

        @SuppressWarnings("unused")
        public ListBoxModel doFillTeamServerProfileNameItems() {
            return VulnerabilityTrendHelper.getProfileNames();
        }

        /**
         * Allows this builder to be available for all classes.
         *
         * @param aClass Passed in class.
         * @return true
         */
        public boolean isApplicable(Class<? extends AbstractProject> aClass) {
            return true;
        }

        /**
         * Display name in the Build Action dropdown.
         *
         * @return String
         */
        public String getDisplayName() {
            return "Contrast Assess";
        }

        /**
         * Save's the publisher's config.jelly data.
         *
         * @param req  StaplerRequest
         * @param json Json of the form for this Publisher
         * @return if the save was successful
         */
        @Override
        public Publisher newInstance(StaplerRequest req, JSONObject json) {
            final JSONArray array = json.optJSONArray("conditions");

            if (array != null) {
                conditions = req.bindJSONToList(ThresholdCondition.class, array);
            } else {
                conditions = new ArrayList<>();

                if (!json.keySet().isEmpty()) {
                    conditions.add(req.bindJSON(ThresholdCondition.class, json.getJSONObject("conditions")));
                }
            }
            teamServerProfileName = (String) json.get("teamServerProfileName");
            overrideGlobalThresholdConditions = (Boolean) json.get("overrideGlobalThresholdConditions");
            queryBy = Integer.parseInt((String) json.get("queryBy"));

            save();

            return new VulnerabilityTrendRecorder(conditions, teamServerProfileName, overrideGlobalThresholdConditions, queryBy);
        }

        public List<ThresholdCondition> getConditions() {
            return conditions;
        }

        public void setConditions(List<ThresholdCondition> conditions) {
            this.conditions = conditions;
        }
    }


    /**
     * Builds a String representation of the Traces found when checking for vulnerabilities.
     *
     * @param traces - traces founding during build
     * @param build  - current build
     */
    private void buildResult(Set<Trace> traces, AbstractBuild<?, ?> build) {
        Map<String, Integer> traceResult = new HashMap<>();
        Map<String, Integer> severityResult = new HashMap<>();

        for (Trace trace : traces) {

            if (severityResult.containsKey(trace.getSeverity())) {
                Integer previousCount = severityResult.get(trace.getSeverity());
                severityResult.put(trace.getSeverity(), previousCount + 1);
            } else {
                severityResult.put(trace.getSeverity(), 1);
            }

            if (traceResult.containsKey(trace.getRule())) {
                Integer previousCount = traceResult.get(trace.getRule());
                traceResult.put(trace.getRule(), previousCount + 1);
            } else {
                traceResult.put(trace.getRule(), 1);
            }
        }

        // Add remaining severities for chart
        for (String severity : VulnerabilityTrendHelper.SEVERITIES) {
            if (!severityResult.containsKey(severity)) {
                severityResult.put(severity, 0);
            }
        }

        VulnerabilityTrendResult result = new VulnerabilityTrendResult(traceResult, severityResult);

        build.addAction(new VulnerabilityFrequencyAction(result, build));
    }
}
