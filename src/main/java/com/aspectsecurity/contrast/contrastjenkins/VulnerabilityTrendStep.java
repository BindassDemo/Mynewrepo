package com.aspectsecurity.contrast.contrastjenkins;

import com.contrastsecurity.exceptions.UnauthorizedException;
import com.contrastsecurity.http.TraceFilterForm;
import com.contrastsecurity.models.Application;
import com.contrastsecurity.models.Organizations;
import com.contrastsecurity.models.SecurityCheck;
import com.contrastsecurity.models.Traces;
import com.contrastsecurity.sdk.ContrastSDK;
import com.google.inject.Inject;
import hudson.AbortException;
import hudson.EnvVars;
import hudson.Extension;
import hudson.model.Result;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.util.ListBoxModel;
import jenkins.model.Jenkins;
import lombok.Getter;
import org.jenkinsci.plugins.workflow.steps.AbstractStepDescriptorImpl;
import org.jenkinsci.plugins.workflow.steps.AbstractStepImpl;
import org.jenkinsci.plugins.workflow.steps.AbstractSynchronousStepExecution;
import org.jenkinsci.plugins.workflow.steps.Step;
import org.jenkinsci.plugins.workflow.steps.StepContextParameter;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.DataBoundSetter;
import org.kohsuke.stapler.QueryParameter;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;

@Getter
public class VulnerabilityTrendStep extends AbstractStepImpl {

    private String profile;

    @DataBoundSetter
    public void setProfile(String profile) {
        this.profile = profile;
    }

    private int count;

    @DataBoundSetter
    public void setCount(int count) {
        this.count = count;
    }

    private String rule;

    @DataBoundSetter
    public void setRule(String rule) {
        this.rule = rule;
    }

    private String severity;

    @DataBoundSetter
    public void setSeverity(String severity) {
        this.severity = severity;
    }

    private String applicationId;

    @DataBoundSetter
    public void setApplicationId(String applicationId) {
        this.applicationId = applicationId;
    }

    private String applicationName;

    @DataBoundSetter
    public void setApplicationName(String applicationName) {
        this.applicationName = applicationName;
    }

    private String appVersionTag;

    @DataBoundSetter
    public void setAppVersionTag(String appVersionTag) {
        this.appVersionTag = appVersionTag;
    }

    private int queryBy;

    @DataBoundSetter
    public void setQueryBy(int queryBy) {
        this.queryBy = queryBy;
    }

    /**
     * Type of agent used to instrument the application
     */
    private String agentType;

    @DataBoundSetter
    public void setAgentType(String agentType) { this.agentType = agentType; }

    @DataBoundConstructor
    public VulnerabilityTrendStep(String profile, int count, String rule, String severity, String applicationId, int queryBy) {
        this.profile = profile;
        this.count = count;
        this.rule = rule;
        this.severity = severity;
        this.applicationId = applicationId;
        this.queryBy = queryBy;
    }

    // Used to build the new instance
    public VulnerabilityTrendStep() {

    }

    @Override
    public VulnerabilityTrendStepDescriptorImpl getDescriptor() {
        Jenkins instance = Jenkins.getInstance();

        if (instance != null) {
            return (VulnerabilityTrendStepDescriptorImpl) instance.getDescriptor(getClass());
        } else {
            return null;
        }
    }

    @Extension
    public static class VulnerabilityTrendStepDescriptorImpl extends AbstractStepDescriptorImpl {

        public VulnerabilityTrendStepDescriptorImpl() {
            super(Execution.class);
        }

        @Override
        public String getFunctionName() {
            return "contrastVerification";
        }

        @Override
        public String getDisplayName() {
            return "Verify vulnerabilities in a build";
        }

        @Override
        public Step newInstance(Map<String, Object> arguments) {
            VulnerabilityTrendStep step = new VulnerabilityTrendStep();

            if (arguments.containsKey("profile")) {
                Object profile = arguments.get("profile");

                if (profile != null) {
                    step.setProfile((String) profile);
                } else {
                    throw new IllegalArgumentException("Profile must be set.");
                }
            }

            if (arguments.containsKey("count")) {
                Object count = arguments.get("count");
                step.setCount((int) count);
            }

            if (arguments.containsKey("rule")) {
                Object rule = arguments.get("rule");
                step.setRule((String) rule);
            }

            if (arguments.containsKey("severity")) {
                Object severity = arguments.get("severity");
                step.setSeverity((String) severity);
            }

            if (arguments.containsKey("applicationId")) {
                String applicationId = (String) arguments.get("applicationId");
                step.setApplicationId(applicationId);
            }

            if (step.getApplicationId() == null) {
                Object applicationName = arguments.get("applicationName");

                if (applicationName != null) {
                    step.setApplicationName((String) applicationName);
                } else {
                    throw new IllegalArgumentException("If Application ID is not set, Application Name must be set.");
                }
            }

            if (step.getApplicationId() == null
                    //// Compatibility fix for plugin versions <=2.6
                    && arguments.containsKey("agentType")) {
                Object agentType = arguments.get("agentType");

                if (agentType != null) {
                    step.setAgentType((String) agentType);
                } else {
                    throw new IllegalArgumentException("If Application ID is not set, Agent Type must be set.");
                }
            }


            if (arguments.containsKey("queryBy")) {
                Object queryBy = arguments.get("queryBy");

                step.setQueryBy((int) queryBy);

                if (step.getQueryBy() == Constants.QUERY_BY_PARAMETER) {
                    step.setAppVersionTag((String) arguments.get("appVersionTag"));
                }
            } else if (arguments.containsKey("appVersionTagFormat")) {
                Object queryBy = arguments.get("appVersionTagFormat");
                step.setQueryBy((int) queryBy);
            }

            return step;
        }

        @SuppressWarnings("unused")
        public ListBoxModel doFillProfileItems() {
            return VulnerabilityTrendHelper.getProfileNames();
        }

        /**
         * Fills the Threshold Category select drop down with application ids.
         *
         * @return ListBoxModel filled with application ids.
         */
        public ListBoxModel doFillApplicationIdItems(@QueryParameter("profile") final String teamServerProfileName) throws IOException {
            return VulnerabilityTrendHelper.getApplicationIds(teamServerProfileName);
        }

        @SuppressWarnings("unused")
        public ListBoxModel doFillRuleItems(@QueryParameter("profile") final String teamServerProfileName) {
            return VulnerabilityTrendHelper.getVulnerabilityTypes(teamServerProfileName);
        }

        @SuppressWarnings("unused")
        public ListBoxModel doFillSeverityItems() {
            return VulnerabilityTrendHelper.getSeverityListBoxModel();
        }
    }

    public static class Execution extends AbstractSynchronousStepExecution<Void> {
        private static final long serialVersionUID = 1L;

        @StepContextParameter
        transient Run<?, ?> build;

        @StepContextParameter
        transient TaskListener taskListener;

        @Inject
        transient VulnerabilityTrendStep step;

        private TraceFilterForm makeFilterFormWithQueryBy() throws IOException, InterruptedException {
            TraceFilterForm filterForm = new TraceFilterForm();

            if (step.getQueryBy() == Constants.QUERY_BY_APP_VERSION_TAG_HIERARCHICAL_FORMAT) {

                String appVersionTag = VulnerabilityTrendHelper.buildAppVersionTagHierarchical(build, step.getApplicationId());

                List<String> appVersionTagsList = new ArrayList<>();
                appVersionTagsList.add(appVersionTag);

                if (step.getApplicationName() != null) {
                    String appVersionTagAppName = VulnerabilityTrendHelper.buildAppVersionTagHierarchical(build, step.getApplicationName());
                    appVersionTagsList.add(appVersionTagAppName);
                }

                filterForm.setAppVersionTags(appVersionTagsList);
            } else if (step.getQueryBy() == Constants.QUERY_BY_START_DATE) {
                filterForm.setStartDate(build.getTime());
            } else if (step.getQueryBy() == Constants.QUERY_BY_PARAMETER) {
                final EnvVars env = build.getEnvironment(taskListener);
                String appVersionTag;

                if (step.getAppVersionTag() != null) {
                    appVersionTag = step.getAppVersionTag();
                } else if (env.get("APPVERSIONTAG") != null) {
                    appVersionTag = env.get("APPVERSIONTAG");
                } else {
                    appVersionTag = "";
                }

                if (appVersionTag.isEmpty()) {
                    VulnerabilityTrendHelper.logMessage(taskListener, "Warning: queryBy Parameter is configured, but appVersionTag is not set. All vulnerabilities will be returned for this application");
                }

                List<String> appVersionTagsList = new ArrayList<>();
                appVersionTagsList.add(appVersionTag);

                filterForm.setAppVersionTags(appVersionTagsList);
            } else {
                String appVersionTag = VulnerabilityTrendHelper.buildAppVersionTag(build, step.getApplicationId());

                List<String> appVersionTagsList = new ArrayList<>();
                appVersionTagsList.add(appVersionTag);

                if (step.getApplicationName() != null) {
                    String appVersionTagAppName = VulnerabilityTrendHelper.buildAppVersionTag(build, step.getApplicationName());
                    appVersionTagsList.add(appVersionTagAppName);
                }

                filterForm.setAppVersionTags(appVersionTagsList);
            }

            return filterForm;
        }

        @Override
        public Void run() throws AbortException, InterruptedException {
            TeamServerProfile teamServerProfile = VulnerabilityTrendHelper.getProfile(step.getProfile());
            final String CONTRAST_ERROR_PREFIX = teamServerProfile.isApplyVulnerableBuildResultOnContrastError() ? "Error: " : "Warning: ";

            if (teamServerProfile == null) {
                VulnerabilityTrendHelper.logMessage(taskListener, "Unable to find TeamServer profile.");
                throw new AbortException("Unable to find TeamServer profile.");
            }

            ContrastSDK contrastSDK = VulnerabilityTrendHelper.createSDK(teamServerProfile.getUsername(), teamServerProfile.getServiceKey(),
                    teamServerProfile.getApiKey(), teamServerProfile.getTeamServerUrl());

            try {
                final Organizations organizations = contrastSDK.getProfileDefaultOrganizations();
                if (organizations == null || organizations.getOrganization() == null) {
                    VulnerabilityTrendHelper.logMessage(taskListener, CONTRAST_ERROR_PREFIX + "No organization found, Check your credentials and URL.");
                    if(teamServerProfile.isApplyVulnerableBuildResultOnContrastError()) {
                        Result profileVulnerableBuildResult = Result.fromString(teamServerProfile.getVulnerableBuildResult());
                        build.setResult(profileVulnerableBuildResult);
                    }
                    return null;
                }

            } catch (UnauthorizedException | IOException e) {
                VulnerabilityTrendHelper.logMessage(taskListener, CONTRAST_ERROR_PREFIX + "Unable to connect to contrast.");
                VulnerabilityTrendHelper.logMessage(taskListener, e.getMessage());
                if(teamServerProfile.isApplyVulnerableBuildResultOnContrastError()) {
                    Result profileVulnerableBuildResult = Result.fromString(teamServerProfile.getVulnerableBuildResult());
                    build.setResult(profileVulnerableBuildResult);
                }
                return null;
            }

            //Convert app name and agent type to app id
            if(step.getApplicationId() == null && step.getApplicationName() != null && step.getAgentType() != null) {
                try {
                    Application app = contrastSDK.getApplicationByNameAndLanguage(teamServerProfile.getOrgUuid(),
                            step.getApplicationName(),
                            VulnerabilityTrendHelper.getAgentTypeFromString(step.getAgentType()));

                    if(app == null) {
                        String errorMessage = String.format(CONTRAST_ERROR_PREFIX + "Application with [name = %s, agentType = %s] not found.", step.getApplicationName(), step.getAgentType());
                        VulnerabilityTrendHelper.logMessage(taskListener, errorMessage);
                        if(teamServerProfile.isApplyVulnerableBuildResultOnContrastError()) {
                            Result profileVulnerableBuildResult = Result.fromString(teamServerProfile.getVulnerableBuildResult());
                            build.setResult(profileVulnerableBuildResult);
                        }
                        return null;
                    } else {
                        step.setApplicationId(app.getId());
                        VulnerabilityTrendHelper.logMessage(taskListener, "Fetched Application : [name = '"+step.getApplicationName()+"', displayName = '"+app.getName()+"', agentType='"+app.getLanguage()+"'] with ID: ["+step.getApplicationId()+"]");
                    }
                } catch (UnauthorizedException | IOException e) {
                    VulnerabilityTrendHelper.logMessage(taskListener, e.getMessage());
                    throw new AbortException("Unable to retrieve information from TeamServer.");
                }
            }

            // Convert app display name to app id
            //// Compatibility fix for plugin versions <=2.6
            if (step.getApplicationId() == null && step.getApplicationName() != null && step.getAgentType() == null) {
                for (App app : teamServerProfile.getApps()) {
                    String subStr = app.getTitle().substring(0, app.getTitle().lastIndexOf(" ("));
                    if (subStr.equals(step.getApplicationName())) {
                        step.setApplicationId(app.getName());
                        break;
                    }
                }
            }
            //validation
            boolean applicationIdExists = VulnerabilityTrendHelper.applicationIdExists(contrastSDK, teamServerProfile.getOrgUuid(), step.getApplicationId());
            if (!applicationIdExists) {
                VulnerabilityTrendHelper.logMessage(taskListener, CONTRAST_ERROR_PREFIX + "Application with ID '" + step.getApplicationId() + "' not found.");
                if (teamServerProfile.isApplyVulnerableBuildResultOnContrastError()) {
                    Result profileVulnerableBuildResult = Result.fromString(teamServerProfile.getVulnerableBuildResult());
                    build.setResult(profileVulnerableBuildResult);
                }
                return null;
            } else {
                VulnerabilityTrendHelper.logMessage(taskListener, "Checking the number of vulnerabilities for " + step.getApplicationId());

                String stepString = step.buildStepString();

                try {
                    SecurityCheck securityCheck = VulnerabilityTrendHelper.makeSecurityCheck(contrastSDK, teamServerProfile.getOrgUuid(), step.getApplicationId());
                    StringBuilder applicationDisplayForConsoleOutputBuilder = new StringBuilder("[");

                    if(step.getApplicationName() != null && !step.getApplicationName().isEmpty()) {
                        applicationDisplayForConsoleOutputBuilder.append("name = " + step.getApplicationName());
                    }
                    if(step.getAgentType() != null && !step.getAgentType().isEmpty()) {
                        applicationDisplayForConsoleOutputBuilder.append(", agentType = "+step.getAgentType());
                    }
                    if(step.getApplicationId() != null && !step.getApplicationId().isEmpty()) {
                        applicationDisplayForConsoleOutputBuilder.append(", appId = "+step.getApplicationId());
                    }
                    applicationDisplayForConsoleOutputBuilder.append("]");

                    String appicationDisplayForConsoleOutput = applicationDisplayForConsoleOutputBuilder.toString();

                    if(securityCheck.getResult() != null) { // jop is defined for app
                        VulnerabilityTrendHelper.logMessage(taskListener,"Your Contrast admin has overridden policies you may have set in Vulnerability Security Controls or the 'query by' parameter");
                        if(securityCheck.getResult()) { //failed a policy
                            VulnerabilityTrendHelper.logMessage(taskListener, "This application did not violate any Contrast policies");
                        } else {
                            try {
                                Result jobResult = VulnerabilityTrendHelper.getJenkinsResultFromJobOutcome(securityCheck.getJobOutcomePolicy().getOutcome());
                                VulnerabilityTrendHelper.logMessage(taskListener,"This application "+appicationDisplayForConsoleOutput+" has failed the Contrast policy '"+securityCheck.getJobOutcomePolicy().getName()+"'");
                                build.setResult(jobResult);
                            } catch (VulnerabilityTrendHelperException e) {
                                throw new AbortException(e.getMessage());
                            }
                        }
                    } else { //regular verify

                        //makeFilterForm
                        TraceFilterForm filterForm = makeFilterFormWithQueryBy();

                        VulnerabilityTrendHelper.logMessage(taskListener, "Checking the step condition where " + stepString);

                        Traces traces;

                        if (step.getSeverity() != null) {
                            filterForm.setSeverities(VulnerabilityTrendHelper.getSeverityList(step.getSeverity()));
                        }

                        if (step.getRule() != null) {
                            filterForm.setVulnTypes(Collections.singletonList(step.getRule()));
                        }
                        VulnerabilityTrendHelper.logMessage(taskListener, "filterForm: " + filterForm);
                        if (step.getQueryBy() == Constants.QUERY_BY_START_DATE || step.getQueryBy() == Constants.QUERY_BY_PARAMETER) {
                            traces = VulnerabilityTrendHelper.getAllTraces(contrastSDK, teamServerProfile.getOrgUuid(), step.getApplicationId(), filterForm);
                        } else {
                            traces = VulnerabilityTrendHelper.getAllTraces(contrastSDK, teamServerProfile.getOrgUuid(), null, filterForm);
                        }

                        if (traces.getCount() > step.getCount()) {
                            Result buildResult = Result.fromString(teamServerProfile.getVulnerableBuildResult());
                            VulnerabilityTrendHelper.logMessage(taskListener, "Failed on the condition where " + stepString);
                            VulnerabilityTrendHelper.logMessage(taskListener, VulnerabilityTrendHelper.getVulnerabilityInfoString(traces));
                            if (buildResult.toString().equals(Result.FAILURE.toString())) {
                                throw new AbortException("Failed on the condition where " + stepString);
                            } else {
                                build.setResult(buildResult);
                                return null;
                            }

                        }
                        VulnerabilityTrendHelper.logMessage(taskListener, "This step has passed successfully");
                    }
                } catch (UnauthorizedException | IOException e) {
                    VulnerabilityTrendHelper.logMessage(taskListener, e.getMessage());
                    throw new AbortException("Unable to retrieve vulnerability information from TeamServer.");
                }
            }
            return null;
        }

        String getBuildName() {
            return build.getParent().getFullName();
        }
    }

    private String buildStepString() {
        StringBuilder sb = new StringBuilder();

        sb.append("count is ").append(count);

        if (severity != null) {
            sb.append(", severity is ").append(severity);
        }

        if (rule != null) {
            sb.append(", rule type is ").append(rule);
        }

        if (applicationId != null) {
            sb.append(", applicationId is ").append(applicationId);
        }

        if (queryBy != 0) {
            sb.append(", queryBy is ").append(queryBy);
        }

        sb.append(".");

        return sb.toString();
    }
}