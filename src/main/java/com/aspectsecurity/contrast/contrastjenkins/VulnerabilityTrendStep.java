package com.aspectsecurity.contrast.contrastjenkins;

import com.google.inject.Inject;
import hudson.Extension;
import hudson.XmlFile;
import hudson.model.Run;
import hudson.model.TaskListener;
import jenkins.model.Jenkins;
import org.jenkinsci.plugins.workflow.steps.AbstractStepDescriptorImpl;
import org.jenkinsci.plugins.workflow.steps.AbstractStepImpl;
import org.jenkinsci.plugins.workflow.steps.AbstractSynchronousNonBlockingStepExecution;
import org.jenkinsci.plugins.workflow.steps.StepContextParameter;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.DataBoundSetter;

import java.io.File;
import java.io.IOException;
import java.util.logging.Logger;

public class VulnerabilityTrendStep extends AbstractStepImpl {

    private static final Logger logger = Logger.getLogger(VulnerabilityTrendStep.class.getName());

    private String countThreshold;
    public String getCountThreshold() { return this.countThreshold; }
    @DataBoundSetter public void setCountThreshold(String countThreshold) {
        this.countThreshold = countThreshold;
    }

    private String ruleThreshold;
    public String getRuleThreshold() { return this.ruleThreshold; }
    @DataBoundSetter public void setRuleThreshold(String ruleThreshold) {
        this.ruleThreshold = ruleThreshold;
    }

    private String severityThresold;
    public String getSeverityThresold() { return this.severityThresold; }
    @DataBoundSetter public void setSeverityThresold(String severityThresold) {
        this.severityThresold = severityThresold;
    }

    @DataBoundConstructor
    public VulnerabilityTrendStep() {

    }

    @Override
    public DescriptorImpl getDescriptor() {
        return Jenkins.getInstance().getDescriptorByType(DescriptorImpl.class);
    }

    @Extension
    public static class DescriptorImpl extends AbstractStepDescriptorImpl {

        private String globalCredentialsId;

        public String getGlobalCredentialsId() {
            return globalCredentialsId;
        }

        public void setGlobalCredentialsId(String globalCredentialsId) {
            this.globalCredentialsId = globalCredentialsId;
        }

        public DescriptorImpl() {
            super(Execution.class);
        }

        @Override
        protected XmlFile getConfigFile() {
            return new XmlFile(new File(Jenkins.getInstance().getRootDir(), this.getId().replace("Step", "") + ".xml"));
        }

        @Override
        public String getFunctionName() {
            return "contrastVerification";
        }

        @Override
        public String getDisplayName() {
            return "Verify vulnerabilities in a build";
        }
    }

    public static class Execution extends AbstractSynchronousNonBlockingStepExecution<Void> {
        private static final long serialVersionUID = 1L;

        @StepContextParameter
        private transient Run<?, ?> build;

        @StepContextParameter
        private transient TaskListener taskListener;

        @Inject
        private transient VulnerabilityTrendStep step;

        private void readGlobalConfiguration() {
            XmlFile config = step.getDescriptor().getConfigFile();
            VulnerabilityTrendStep.DescriptorImpl cfg = new VulnerabilityTrendStep.DescriptorImpl();
            try {
                config.unmarshal(cfg);
                step.getDescriptor().setGlobalCredentialsId(cfg.getGlobalCredentialsId());
            } catch(IOException e) {
                logger.warning("Unable to read BitbucketBuildStatusNotifier configuration");
            }
        }

        @Override
        public Void run() throws Exception {
            this.readGlobalConfiguration();

            return null;
        }
    }
}