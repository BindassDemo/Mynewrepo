package com.aspectsecurity.contrast.contrastjenkins;

import com.contrastsecurity.http.TraceFilterForm;
import com.contrastsecurity.models.Trace;
import com.contrastsecurity.models.Traces;
import com.contrastsecurity.sdk.ContrastSDK;
import com.google.inject.Inject;
import hudson.AbortException;
import hudson.Extension;
import hudson.XmlFile;
import hudson.model.Run;
import hudson.model.TaskListener;
import jenkins.model.Jenkins;
import lombok.Getter;
import org.jenkinsci.plugins.workflow.steps.AbstractStepDescriptorImpl;
import org.jenkinsci.plugins.workflow.steps.AbstractStepImpl;
import org.jenkinsci.plugins.workflow.steps.AbstractSynchronousNonBlockingStepExecution;
import org.jenkinsci.plugins.workflow.steps.StepContextParameter;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.DataBoundSetter;

import java.io.File;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Logger;

@Getter
public class VulnerabilityTrendStep extends AbstractStepImpl {

    private static final Logger logger = Logger.getLogger(VulnerabilityTrendStep.class.getName());

    private String profileName;

    @DataBoundSetter
    public void setProfileName(String profileName) {
        this.profileName = profileName;
    }

    private String countThreshold;

    @DataBoundSetter
    public void setCountThreshold(String countThreshold) {
        this.countThreshold = countThreshold;
    }

    private String ruleThreshold;

    @DataBoundSetter
    public void setRuleThreshold(String ruleThreshold) {
        this.ruleThreshold = ruleThreshold;
    }

    private String severityThreshold;

    @DataBoundSetter
    public void setSeverityThresold(String severityThreshold) {
        this.severityThreshold = severityThreshold;
    }

    @DataBoundConstructor
    public VulnerabilityTrendStep() {

    }

    @Override
    public VulnerabilityTrendStepDescriptorImpl getDescriptor() {
        return Jenkins.getInstance().getDescriptorByType(VulnerabilityTrendStepDescriptorImpl.class);
    }

    @Extension
    public static class VulnerabilityTrendStepDescriptorImpl extends AbstractStepDescriptorImpl {

        public VulnerabilityTrendStepDescriptorImpl() {
            super(Execution.class);
        }

        @Override
        protected XmlFile getConfigFile() {
            return new XmlFile(new File(Jenkins.getInstance().getRootDir(), this.getId().replace("Step", "") + ".xml"));
        }

        @Override
        public String getFunctionName() {
            return "contrastVerification";
        }

        @Override
        public String getDisplayName() {
            return "Verify vulnerabilities in a build";
        }
    }

    public static class Execution extends AbstractSynchronousNonBlockingStepExecution<Void> {
        private static final long serialVersionUID = 1L;

        @StepContextParameter
        private transient TeamServerProfile teamServerProfile;

        @StepContextParameter
        private transient Run<?, ?> build;

        @StepContextParameter
        private transient TaskListener taskListener;

        @Inject
        private transient VulnerabilityTrendStep step;

        private void readGlobalConfiguration() {
            teamServerProfile = VulnerabilityTrendHelper.getProfile(step.getProfileName());
        }

        @Override
        public Void run() throws Exception {

            this.readGlobalConfiguration();

            String d = build.getDisplayName();
            int b = build.getNumber();

            VulnerabilityTrendHelper.logMessage(taskListener, "Checking the number of vulnerabilities for this application.");
            ContrastSDK contrastSDK;
            Traces traces;
            Set<Trace> resultTraces = new HashSet<>();

            if (teamServerProfile.getApplicationName() == null) {
                throw new AbortException("An application name must be configured to check for vulnerabilities.");
            }

            if (teamServerProfile.getOrgUuid() == null) {
                throw new AbortException("An organization id must be configured to check for vulnerabilities.");
            }

            if (teamServerProfile.getServerName() == null) {
                throw new AbortException("A server name must be configured to check for vulnerabilities.");
            }

            contrastSDK = new ContrastSDK(teamServerProfile.getUsername(), teamServerProfile.getServiceKey(), teamServerProfile.getApiKey(), teamServerProfile.getTeamServerUrl());

            String applicationId = VulnerabilityTrendHelper.getApplicationId(contrastSDK, teamServerProfile.getOrgUuid(), teamServerProfile.getApplicationName());
            long serverId = VulnerabilityTrendHelper.getServerId(contrastSDK, teamServerProfile.getOrgUuid(), teamServerProfile.getServerName(), applicationId);

            // iterate over conditions; fail on first
            VulnerabilityTrendHelper.logMessage(taskListener, "Checking the threshold condition where " + step.getCountThreshold());

            try {
                TraceFilterForm filterForm = new TraceFilterForm();
                filterForm.setServerIds(Collections.singletonList(serverId));

                if (step.getSeverityThreshold() != null) {
                    filterForm.setSeverities(VulnerabilityTrendHelper.getSeverityList(step.getSeverityThreshold()));
                }

                if (step.getRuleThreshold() != null) {
                    filterForm.setVulnTypes(Collections.singletonList(step.getRuleThreshold()));
                }

                traces = contrastSDK.getTraces(teamServerProfile.getOrgUuid(), applicationId, filterForm);
            } catch (Exception e) {
                VulnerabilityTrendHelper.logMessage(taskListener, e.getMessage());
                throw new AbortException("Unable to retrieve vulnerability information from TeamServer.");
            }

            resultTraces.addAll(traces.getTraces());

            int thresholdCount = Integer.parseInt(step.getCountThreshold());

            if (traces.getCount() > thresholdCount) {
                // buildResult(resultTraces, build);

                throw new AbortException("Failed on the threshold condition where " + step.getCountThreshold());
            }

            // buildResult(resultTraces, build);

            VulnerabilityTrendHelper.logMessage(taskListener, "This build passes all vulnerability threshold conditions!");

            return null;
        }
    }
}