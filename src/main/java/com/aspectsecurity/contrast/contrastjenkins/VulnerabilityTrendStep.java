package com.aspectsecurity.contrast.contrastjenkins;

import com.contrastsecurity.exceptions.UnauthorizedException;
import com.contrastsecurity.http.TraceFilterForm;
import com.contrastsecurity.models.Application;
import com.contrastsecurity.models.Applications;
import com.contrastsecurity.models.Traces;
import com.contrastsecurity.sdk.ContrastSDK;
import com.google.inject.Inject;
import hudson.AbortException;
import hudson.Extension;
import hudson.model.Result;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.util.ListBoxModel;
import jenkins.model.Jenkins;
import lombok.Getter;
import org.jenkinsci.plugins.workflow.steps.*;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.DataBoundSetter;
import org.kohsuke.stapler.QueryParameter;

import java.io.IOException;
import java.util.Collections;
import java.util.Map;

@Getter
public class VulnerabilityTrendStep extends AbstractStepImpl {

    private String profile;

    @DataBoundSetter
    public void setProfile(String profile) {
        this.profile = profile;
    }

    private int count;

    @DataBoundSetter
    public void setCount(int count) {
        this.count = count;
    }

    private String rule;

    @DataBoundSetter
    public void setRule(String rule) {
        this.rule = rule;
    }

    private String severity;

    @DataBoundSetter
    public void setSeverity(String severity) {
        this.severity = severity;
    }

    private String applicationName;

    @DataBoundSetter
    public void setApplicationName(String applicationName) { this.applicationName = applicationName; }

    private int appVersionTagFormat;

    @DataBoundSetter
    public void setAppVersionTagFormat(int appVersionTagFormat) {
        this.appVersionTagFormat = appVersionTagFormat;
    }

    @DataBoundConstructor
    public VulnerabilityTrendStep(String profile, int count, String rule, String severity, String applicationName, int appVersionTagFormat) {
        this.profile = profile;
        this.count = count;
        this.rule = rule;
        this.severity = severity;
        this.applicationName = applicationName;
        this.appVersionTagFormat = appVersionTagFormat;
    }

    // Used to build the new instance
    public VulnerabilityTrendStep() {

    }

    @Override
    public VulnerabilityTrendStepDescriptorImpl getDescriptor() {
        Jenkins instance = Jenkins.getInstance();

        if (instance != null) {
            return (VulnerabilityTrendStepDescriptorImpl) instance.getDescriptor(getClass());
        } else {
            return null;
        }
    }

    @Extension
    public static class VulnerabilityTrendStepDescriptorImpl extends AbstractStepDescriptorImpl {

        public VulnerabilityTrendStepDescriptorImpl() {
            super(Execution.class);
        }

        @Override
        public String getFunctionName() {
            return "contrastVerification";
        }

        @Override
        public String getDisplayName() {
            return "Verify vulnerabilities in a build";
        }

        @Override
        public Step newInstance(Map<String, Object> arguments) {
            VulnerabilityTrendStep step = new VulnerabilityTrendStep();

            if (arguments.containsKey("profile")) {
                Object profile = arguments.get("profile");

                if (profile != null) {
                    step.setProfile((String) profile);
                } else {
                    throw new IllegalArgumentException("Profile must be set.");
                }
            }

            if (arguments.containsKey("count")) {
                Object count = arguments.get("count");

                if (count != null) {
                    step.setCount((int) count);
                } else {
                    throw new IllegalArgumentException("Count must be set.");
                }
            }

            if (arguments.containsKey("rule")) {
                Object rule = arguments.get("rule");

                step.setRule((String) rule);
            }

            if (arguments.containsKey("severity")) {
                Object severity = arguments.get("severity");

                step.setSeverity((String) severity);
            }

            if (arguments.containsKey("applicationName")) {
                Object applicationName = arguments.get("applicationName");

                step.setApplicationName((String) applicationName);
            }

            if (arguments.containsKey("appVersionTagFormat")) {
                Object appVersionTagFormat = arguments.get("appVersionTagFormat");

                step.setAppVersionTagFormat((int) appVersionTagFormat);
            }

            return step;
        }

        @SuppressWarnings("unused")
        public ListBoxModel doFillProfileItems() {
            return VulnerabilityTrendHelper.getProfileNames();
        }

        @SuppressWarnings("unused")
        public ListBoxModel doFillRuleItems(@QueryParameter("teamServerProfileName") final String teamServerProfileName) {
            return VulnerabilityTrendHelper.getVulnerabilityTypes(teamServerProfileName);
        }

        @SuppressWarnings("unused")
        public ListBoxModel doFillSeverityItems() {
            return VulnerabilityTrendHelper.getSeverityListBoxModel();
        }
    }

    public static class Execution extends AbstractSynchronousStepExecution<Void> {
        private static final long serialVersionUID = 1L;

        @StepContextParameter
        transient Run<?, ?> build;

        @StepContextParameter
        transient TaskListener taskListener;

        @Inject
        transient VulnerabilityTrendStep step;

        @Override
        public Void run() throws AbortException {

            TeamServerProfile teamServerProfile = VulnerabilityTrendHelper.getProfile(step.getProfile());

            if (teamServerProfile == null) {
                VulnerabilityTrendHelper.logMessage(taskListener, "Unable to find TeamServer profile.");
                throw new AbortException("Unable to find TeamServer profile.");
            }

            if (step.getApplicationName() == null || step.getApplicationName().isEmpty()) {
                step.setApplicationName(getBuildName());
            }

            if (step.getAppVersionTagFormat() == 0) {
                step.setAppVersionTagFormat(Constants.DEFAULT_APP_VERSION_TAG_FORMAT);
            }

            VulnerabilityTrendHelper.logMessage(taskListener, "Checking the number of vulnerabilities for " + step.getApplicationName());
            ContrastSDK contrastSDK = VulnerabilityTrendHelper.createSDK(teamServerProfile.getUsername(), teamServerProfile.getServiceKey(),
                    teamServerProfile.getApiKey(), teamServerProfile.getTeamServerUrl());

            String applicationId = getApplicationId(contrastSDK, teamServerProfile.getOrgUuid(), step.getApplicationName());
            if (applicationId != null && applicationId.equals("")) {
                VulnerabilityTrendHelper.logMessage(taskListener, "Application with name '" + step.getApplicationName() + "' not found.");
                if (teamServerProfile.isFailOnWrongApplicationName()) {
                    throw new AbortException("Application with name '" + step.getApplicationName() + "' not found.");
                }
            }

            Traces traces;

            String stepString = step.buildStepString();

            VulnerabilityTrendHelper.logMessage(taskListener, "Checking the step condition where " + stepString);

            try {
                TraceFilterForm filterForm = new TraceFilterForm();

                if (step.getApplicationName() != null) {
                    if (step.getAppVersionTagFormat() == Constants.HIERARCHICAL_APP_VERSION_TAG_FORMAT) {
                        filterForm.setAppVersionTags(Collections.singletonList(VulnerabilityTrendHelper.buildAppVersionTagHierarchical(build, step.getApplicationName())));
                    } else {
                        filterForm.setAppVersionTags(Collections.singletonList(VulnerabilityTrendHelper.buildAppVersionTag(build, step.getApplicationName())));
                    }
                }

                if (step.getSeverity() != null) {
                    filterForm.setSeverities(VulnerabilityTrendHelper.getSeverityList(step.getSeverity()));
                }

                if (step.getRule() != null) {
                    filterForm.setVulnTypes(Collections.singletonList(step.getRule()));
                }

                traces = contrastSDK.getTracesInOrg(teamServerProfile.getOrgUuid(), filterForm);
            } catch (Exception e) {
                VulnerabilityTrendHelper.logMessage(taskListener, e.getMessage());
                throw new AbortException("Unable to retrieve vulnerability information from TeamServer.");
            }

            if (traces.getCount() > step.getCount()) {
                Result buildResult = Result.fromString(teamServerProfile.getVulnerableBuildResult());
                VulnerabilityTrendHelper.logMessage(taskListener, "Failed on the condition where " + stepString);
                VulnerabilityTrendHelper.logMessage(taskListener, VulnerabilityTrendHelper.getVulnerabilityInfoString(traces));
                if (buildResult.toString().equals(Result.FAILURE.toString())) {
                    throw new AbortException("Failed on the condition where " + stepString);
                } else {
                    build.setResult(buildResult);
                    return null;
                }

            }

            VulnerabilityTrendHelper.logMessage(taskListener, "This step has passed successfully");

            return null;
        }

        String getBuildName() {
            return build.getParent().getDisplayName();
        }
    }

    private String buildStepString() {
        StringBuilder sb = new StringBuilder();

        sb.append("count is ").append(count);

        if (severity != null) {
            sb.append(", severity is ").append(severity);
        }

        if (rule != null) {
            sb.append(", rule type is ").append(rule);
        }

        if (applicationName != null) {
            sb.append(", applicationName is ").append(applicationName);
        }

        sb.append(".");

        return sb.toString();
    }

    private static String getApplicationId(ContrastSDK sdk, String organizationUuid, String applicationName) {

        Applications applications;

        try {
            applications = sdk.getApplications(organizationUuid);
        } catch (IOException | UnauthorizedException e) {
            return "";
        }

        for (Application application : applications.getApplications()) {
            if (applicationName.equals(application.getName())) {
                return application.getId();
            }
        }

        return "";
    }
}