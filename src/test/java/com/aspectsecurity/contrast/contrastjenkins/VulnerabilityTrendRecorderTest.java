package com.aspectsecurity.contrast.contrastjenkins;

import com.contrastsecurity.http.TraceFilterForm;
import com.contrastsecurity.models.AgentType;
import com.contrastsecurity.models.Application;
import com.contrastsecurity.models.Applications;
import com.contrastsecurity.models.TraceFilter;
import com.contrastsecurity.models.Traces;
import com.contrastsecurity.sdk.ContrastSDK;
import hudson.AbortException;
import hudson.Launcher;
import hudson.model.*;
import jenkins.model.Jenkins;
import org.apache.xerces.impl.xpath.regex.Match;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Matchers;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;

import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.assertTrue;
import static org.mockito.BDDMockito.given;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.when;
import static org.powermock.api.mockito.PowerMockito.mock;

@RunWith(PowerMockRunner.class)
@PrepareForTest({Jenkins.class, VulnerabilityTrendRecorder.class, VulnerabilityTrendHelper.class})
public class VulnerabilityTrendRecorderTest {

    @Mock
    Jenkins jenkins;

    @Mock
    VulnerabilityTrendRecorder.DescriptorImpl vulnerabilityTrendRecorderDescriptor;

    @Before
    public void setUp() {
        PowerMockito.mockStatic(Jenkins.class);
        PowerMockito.mockStatic(VulnerabilityTrendRecorder.class);
        PowerMockito.mockStatic(VulnerabilityTrendHelper.class);

        when(jenkins.getDescriptorByType(VulnerabilityTrendRecorder.DescriptorImpl.class)).thenReturn(vulnerabilityTrendRecorderDescriptor);
        when(Jenkins.getInstance()).thenReturn(jenkins);
    }

    @Test
    public void testSuccessfulBuild() throws Exception {

        List<ThresholdCondition> conditions = new ArrayList<>();
        ThresholdCondition thresholdCondition = mock(ThresholdCondition.class);
        when(thresholdCondition.getApplicationId()).thenReturn("test");
        when(thresholdCondition.getThresholdCount()).thenReturn(0);
        when(thresholdCondition.getThresholdSeverity()).thenReturn("test");
        when(thresholdCondition.getThresholdVulnType()).thenReturn("test");
        conditions.add(thresholdCondition);

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
                "test", true, Constants.QUERY_BY_APP_VERSION_TAG_DEFAULT_FORMAT);

        Traces tracesMock = mock(Traces.class);
        when(tracesMock.getCount()).thenReturn(0);

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);

        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profile = mock(TeamServerProfile.class);
        given(profile.getName()).willReturn("local");
        given(profile.isAllowGlobalThresholdConditionsOverride()).willReturn(true);

        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profile);

        Applications applications = mock(Applications.class);
        Application application = mock(Application.class);
        when(application.getId()).thenReturn("test");
        when(application.getName()).thenReturn("test");

        when(contrastSDKMock.getApplications(anyString())).thenReturn(applications);
        when(contrastSDKMock.getTracesInOrg(anyString(), any(TraceFilterForm.class))).thenReturn(tracesMock);

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);
        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(1);

        assertTrue(vulnerabilityTrendRecorder.perform(build, launcher, listener));
    }

    @Test(expected = AbortException.class)
    public void testUnsuccessfulBuild() throws Exception {

        List<ThresholdCondition> conditions = new ArrayList<>();
        ThresholdCondition thresholdCondition = mock(ThresholdCondition.class);
        when(thresholdCondition.getApplicationId()).thenReturn("test");
        when(thresholdCondition.getThresholdCount()).thenReturn(0);
        when(thresholdCondition.getThresholdSeverity()).thenReturn("test");
        when(thresholdCondition.getThresholdVulnType()).thenReturn("test");
        conditions.add(thresholdCondition);

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
                "test", true, Constants.QUERY_BY_APP_VERSION_TAG_DEFAULT_FORMAT);

        Traces tracesMock = mock(Traces.class);
        when(tracesMock.getCount()).thenReturn(10);

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);

        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);
        given(VulnerabilityTrendHelper.applicationIdExists(any(ContrastSDK.class), anyString(), anyString())).willReturn(true);

        TeamServerProfile profile = mock(TeamServerProfile.class);
        given(profile.getName()).willReturn("local");
        given(profile.isAllowGlobalThresholdConditionsOverride()).willReturn(true);
        given(profile.getVulnerableBuildResult()).willReturn(Result.FAILURE.toString());
        given(profile.isFailOnWrongApplicationId()).willReturn(true);

        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profile);
        given(VulnerabilityTrendHelper.getAllTraces(any(ContrastSDK.class), anyString(), anyString(), any(TraceFilterForm.class))).willReturn(tracesMock);

        Applications applications = mock(Applications.class);
        Application application = mock(Application.class);
        when(application.getId()).thenReturn("test");
        when(application.getName()).thenReturn("test");

        when(contrastSDKMock.getApplications(anyString())).thenReturn(applications);
        when(contrastSDKMock.getTracesInOrg(anyString(), any(TraceFilterForm.class))).thenReturn(tracesMock);

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);
        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(1);

        vulnerabilityTrendRecorder.perform(build, launcher, listener);
    }

    @Test
    public void testSuccessfulBuildWithNullCondition() throws Exception {

        List<ThresholdCondition> conditions = new ArrayList<>();
        ThresholdCondition thresholdCondition = mock(ThresholdCondition.class);
        when(thresholdCondition.getApplicationId()).thenReturn("test");
        when(thresholdCondition.getThresholdCount()).thenReturn(0);
        when(thresholdCondition.getThresholdSeverity()).thenReturn(null);
        when(thresholdCondition.getThresholdVulnType()).thenReturn(null);
        conditions.add(thresholdCondition);

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
                "test", true, Constants.QUERY_BY_APP_VERSION_TAG_DEFAULT_FORMAT);

        Traces tracesMock = mock(Traces.class);
        when(tracesMock.getCount()).thenReturn(0);

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);

        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profile = mock(TeamServerProfile.class);
        given(profile.getName()).willReturn("local");
        given(profile.isAllowGlobalThresholdConditionsOverride()).willReturn(true);
        given(profile.getVulnerableBuildResult()).willReturn(Result.FAILURE.toString());

        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profile);

        Applications applications = mock(Applications.class);
        Application application = mock(Application.class);
        when(application.getId()).thenReturn("test");
        when(application.getName()).thenReturn("test");

        when(contrastSDKMock.getApplications(anyString())).thenReturn(applications);
        when(contrastSDKMock.getTracesInOrg(anyString(), any(TraceFilterForm.class))).thenReturn(tracesMock);

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);
        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(1);

        assertTrue(vulnerabilityTrendRecorder.perform(build, launcher, listener));
    }

    @Test
    public void testSuccessfulBuildWithAppNameAppFound() throws Exception {
        List<ThresholdCondition> conditions = new ArrayList<>();
        ThresholdCondition thresholdCondition = mock(ThresholdCondition.class);
        when(thresholdCondition.getMatchBy()).thenReturn(MatchBy.APPLICATION_ORIGIN_NAME);
        when(thresholdCondition.getThresholdCount()).thenReturn(0);
        when(thresholdCondition.getThresholdSeverity()).thenReturn(null);
        when(thresholdCondition.getThresholdVulnType()).thenReturn(null);
        when(thresholdCondition.getApplicationOriginName()).thenReturn("test");
        when(thresholdCondition.getAgentType()).thenReturn("testlang");
        when(thresholdCondition.isFailOnAppNotFound()).thenReturn(true);
        conditions.add(thresholdCondition);

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
                "test", true, Constants.QUERY_BY_APP_VERSION_TAG_DEFAULT_FORMAT);

        Traces tracesMock = mock(Traces.class);
        when(tracesMock.getCount()).thenReturn(0);

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);

        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profile = mock(TeamServerProfile.class);
        given(profile.getName()).willReturn("local");
        given(profile.isAllowGlobalThresholdConditionsOverride()).willReturn(true);
        given(profile.getVulnerableBuildResult()).willReturn(Result.FAILURE.toString());

        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profile);

        Application application = mock(Application.class);
        when(application.getId()).thenReturn("testId");

        when(contrastSDKMock.getApplicationByNameAndLanguage(anyString(), anyString(), any(AgentType.class))).thenReturn(application);

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);
        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(1);

        assertTrue(vulnerabilityTrendRecorder.perform(build, launcher, listener));
    }

    @Test(expected = AbortException.class)
    public void testUnSuccessfulBuildAppNameAppNotFound() throws Exception {
        List<ThresholdCondition> conditions = new ArrayList<>();
        ThresholdCondition thresholdCondition = mock(ThresholdCondition.class);
        when(thresholdCondition.getMatchBy()).thenReturn(MatchBy.APPLICATION_ORIGIN_NAME);
        when(thresholdCondition.getThresholdCount()).thenReturn(0);
        when(thresholdCondition.getThresholdSeverity()).thenReturn(null);
        when(thresholdCondition.getThresholdVulnType()).thenReturn(null);
        when(thresholdCondition.getApplicationOriginName()).thenReturn("test");
        when(thresholdCondition.getAgentType()).thenReturn("testlang");
        when(thresholdCondition.isFailOnAppNotFound()).thenReturn(true);
        conditions.add(thresholdCondition);

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
                "test", true, Constants.QUERY_BY_APP_VERSION_TAG_DEFAULT_FORMAT);

        Traces tracesMock = mock(Traces.class);
        when(tracesMock.getCount()).thenReturn(0);

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);

        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profile = mock(TeamServerProfile.class);
        given(profile.getName()).willReturn("local");
        given(profile.isAllowGlobalThresholdConditionsOverride()).willReturn(true);
        given(profile.getVulnerableBuildResult()).willReturn(Result.FAILURE.toString());

        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profile);

        when(contrastSDKMock.getApplicationByNameAndLanguage(anyString(), anyString(), any(AgentType.class))).thenReturn(null); //app not found

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);
        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(1);

        vulnerabilityTrendRecorder.perform(build, launcher, listener);

    }


    @Test
    public void testSuccessfulBuildStatusFilterEmpty() throws Exception {

        List<ThresholdCondition> conditions = new ArrayList<>();
        ThresholdCondition thresholdCondition = mock(ThresholdCondition.class);
        when(thresholdCondition.getApplicationId()).thenReturn("test");
        when(thresholdCondition.getThresholdCount()).thenReturn(0);
        when(thresholdCondition.getThresholdSeverity()).thenReturn("test");
        when(thresholdCondition.getThresholdVulnType()).thenReturn("test");
        conditions.add(thresholdCondition);

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
                "test", true, Constants.QUERY_BY_APP_VERSION_TAG_DEFAULT_FORMAT);

        final Traces tracesMock = mock(Traces.class);
        when(tracesMock.getCount()).thenReturn(0);

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);

        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profile = mock(TeamServerProfile.class);
        given(profile.getName()).willReturn("local");
        given(profile.isAllowGlobalThresholdConditionsOverride()).willReturn(true);
        given(profile.getVulnerableBuildResult()).willReturn(Result.FAILURE.toString());

        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profile);

        Applications applications = mock(Applications.class);
        Application application = mock(Application.class);
        when(application.getId()).thenReturn("test");
        when(application.getName()).thenReturn("test");

        when(contrastSDKMock.getApplications(anyString())).thenReturn(applications);
        when(contrastSDKMock.getTracesInOrg(anyString(), any(TraceFilterForm.class))).then(new Answer<Traces>() {
            public Traces answer(InvocationOnMock invocationOnMock) {
                TraceFilterForm traceFilterForm = invocationOnMock.getArgumentAt(1, TraceFilterForm.class);
                Assert.assertNull(traceFilterForm.getStatus());
                return tracesMock;
            }
        });

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);
        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(1);

        assertTrue(vulnerabilityTrendRecorder.perform(build, launcher, listener));
    }

    @Test
    public void testSuccessfulBuildStatusFilter() throws Exception {

        List<ThresholdCondition> conditions = new ArrayList<>();
        ThresholdCondition thresholdCondition = mock(ThresholdCondition.class);
        when(thresholdCondition.getApplicationId()).thenReturn("test");
        when(thresholdCondition.getThresholdCount()).thenReturn(0);
        when(thresholdCondition.getThresholdSeverity()).thenReturn("test");
        when(thresholdCondition.getThresholdVulnType()).thenReturn("test");

        ArrayList<String> status = new ArrayList<>();
        status.add(Constants.VULNERABILITY_STATUS_AUTO_REMEDIATED);
        status.add(Constants.VULNERABILITY_STATUS_CONFIRMED);
        status.add(Constants.VULNERABILITY_STATUS_SUSPICIOUS);
        when(thresholdCondition.getVulnerabilityStatuses()).thenReturn(status);

        conditions.add(thresholdCondition);

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
                "test", true, Constants.QUERY_BY_APP_VERSION_TAG_DEFAULT_FORMAT);

        final Traces tracesMock = mock(Traces.class);
        when(tracesMock.getCount()).thenReturn(0);

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);

        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profile = mock(TeamServerProfile.class);
        given(profile.getName()).willReturn("local");
        given(profile.isAllowGlobalThresholdConditionsOverride()).willReturn(true);
        given(profile.getVulnerableBuildResult()).willReturn(Result.FAILURE.toString());

        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profile);

        Applications applications = mock(Applications.class);
        Application application = mock(Application.class);
        when(application.getId()).thenReturn("test");
        when(application.getName()).thenReturn("test");

        when(contrastSDKMock.getApplications(anyString())).thenReturn(applications);
        when(contrastSDKMock.getTracesInOrg(anyString(), any(TraceFilterForm.class))).then(new Answer<Traces>() {
            public Traces answer(InvocationOnMock invocationOnMock) {
                TraceFilterForm traceFilterForm = invocationOnMock.getArgumentAt(1, TraceFilterForm.class);
                Assert.assertNotNull(traceFilterForm.getStatus());
                Assert.assertEquals(traceFilterForm.getStatus().size(), 3);
                Assert.assertTrue(traceFilterForm.getStatus().contains(Constants.VULNERABILITY_STATUS_AUTO_REMEDIATED));
                Assert.assertTrue(traceFilterForm.getStatus().contains(Constants.VULNERABILITY_STATUS_CONFIRMED));
                Assert.assertTrue(traceFilterForm.getStatus().contains(Constants.VULNERABILITY_STATUS_SUSPICIOUS));
                return tracesMock;
            }
        });

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);
        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(1);

        assertTrue(vulnerabilityTrendRecorder.perform(build, launcher, listener));
    }


    @Test
    public void testSuccessfulBuildAppVersionTag() throws Exception {

        List<ThresholdCondition> conditions = new ArrayList<>();
        final String appName = "WebGoat";
        final int buildNumber = 1;
        final String buildParentFullName = "Project";
        ThresholdCondition thresholdCondition = new ThresholdCondition(1, "High", "All", 0,null,
                "test", true, true, true, true, true,
                true, true, true, true);
        conditions.add(thresholdCondition);

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
                "test", true, Constants.QUERY_BY_APP_VERSION_TAG_HIERARCHICAL_FORMAT);

        when(VulnerabilityTrendHelper.buildAppVersionTagHierarchical(any(Build.class), anyString())).thenCallRealMethod();

        final Traces tracesMock = mock(Traces.class);
        when(tracesMock.getCount()).thenReturn(0);

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);

        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profile = mock(TeamServerProfile.class);
        given(profile.getName()).willReturn("local");
        given(profile.isAllowGlobalThresholdConditionsOverride()).willReturn(true);
        given(profile.getVulnerableBuildResult()).willReturn(Result.FAILURE.toString());

        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profile);

        Applications applications = mock(Applications.class);
        Application application = mock(Application.class);
        when(application.getId()).thenReturn("test");
        when(application.getName()).thenReturn("test");

        when(contrastSDKMock.getApplications(anyString())).thenReturn(applications);
        when(contrastSDKMock.getTracesInOrg(anyString(), any(TraceFilterForm.class))).then(new Answer<Traces>() {
            public Traces answer(InvocationOnMock invocationOnMock) {
                TraceFilterForm traceFilterForm = invocationOnMock.getArgumentAt(1, TraceFilterForm.class);
                Assert.assertEquals(traceFilterForm.getAppVersionTags().get(0), appName + "-" + buildParentFullName + "-" + buildNumber);
                return tracesMock;
            }
        });

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);

        AbstractProject<?, ?> parent = mock(AbstractProject.class);

        ItemGroup itemGroup = mock(ItemGroup.class);
        when(itemGroup.getFullName()).thenReturn("");
        when(parent.getParent()).thenReturn(itemGroup);

        when(parent.getFullName()).thenReturn(buildParentFullName);

        Mockito.<AbstractProject<?, ?>>when(build.getParent()).thenReturn(parent);

        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(buildNumber);

        assertTrue(vulnerabilityTrendRecorder.perform(build, launcher, listener));
    }

}