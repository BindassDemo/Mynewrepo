package com.aspectsecurity.contrast.contrastjenkins;

import com.contrastsecurity.exceptions.UnauthorizedException;
import com.contrastsecurity.http.TraceFilterForm;
import com.contrastsecurity.models.AgentType;
import com.contrastsecurity.models.Application;
import com.contrastsecurity.models.Applications;
import com.contrastsecurity.models.JobOutcomePolicy;
import com.contrastsecurity.models.Organization;
import com.contrastsecurity.models.Organizations;
import com.contrastsecurity.models.SecurityCheck;
import com.contrastsecurity.models.Trace;
import com.contrastsecurity.models.Traces;
import com.contrastsecurity.sdk.ContrastSDK;
import com.google.common.collect.Lists;
import hudson.AbortException;
import hudson.Launcher;
import hudson.model.AbstractBuild;
import hudson.model.AbstractProject;
import hudson.model.Build;
import hudson.model.BuildListener;
import hudson.model.ItemGroup;
import hudson.model.Result;
import jenkins.model.Jenkins;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.assertTrue;
import static org.mockito.BDDMockito.given;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyLong;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.powermock.api.mockito.PowerMockito.mock;
import static org.powermock.api.mockito.PowerMockito.verifyStatic;

@RunWith(PowerMockRunner.class)
@PrepareForTest({Jenkins.class, VulnerabilityTrendRecorder.class, VulnerabilityTrendHelper.class})
public class VulnerabilityTrendRecorderTest {

    @Mock
    Jenkins jenkins;

    @Mock
    VulnerabilityTrendRecorder.DescriptorImpl vulnerabilityTrendRecorderDescriptor;

    @Before
    public void setUp() {
        PowerMockito.mockStatic(Jenkins.class);
        PowerMockito.mockStatic(VulnerabilityTrendRecorder.class);
        PowerMockito.mockStatic(VulnerabilityTrendHelper.class);

        when(jenkins.getDescriptorByType(VulnerabilityTrendRecorder.DescriptorImpl.class)).thenReturn(vulnerabilityTrendRecorderDescriptor);
        when(Jenkins.getInstance()).thenReturn(jenkins);
    }

    @Test
    public void testSuccessfulBuild() throws Exception {

        List<ThresholdCondition> conditions = new ArrayList<>();
        ThresholdCondition thresholdCondition = mock(ThresholdCondition.class);
        when(thresholdCondition.getApplicationId()).thenReturn("test");
        when(thresholdCondition.getThresholdCount()).thenReturn(0);
        when(thresholdCondition.getThresholdSeverity()).thenReturn("test");
        when(thresholdCondition.getThresholdVulnType()).thenReturn("test");
        conditions.add(thresholdCondition);

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
                "test", true, Constants.QUERY_BY_APP_VERSION_TAG_DEFAULT_FORMAT);

        Traces tracesMock = mock(Traces.class);
        when(tracesMock.getCount()).thenReturn(0);

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);

        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profile = mock(TeamServerProfile.class);
        given(profile.getName()).willReturn("local");
        given(profile.isAllowGlobalThresholdConditionsOverride()).willReturn(true);

        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profile);

        Applications applications = mock(Applications.class);
        Application application = mock(Application.class);
        when(application.getId()).thenReturn("test");
        when(application.getName()).thenReturn("test");

        when(contrastSDKMock.getApplications(anyString())).thenReturn(applications);
        when(contrastSDKMock.getTracesInOrg(anyString(), any(TraceFilterForm.class))).thenReturn(tracesMock);

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);
        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(1);

        Organizations mockOrgs = mock(Organizations.class);
        Organization mockOrg = mock(Organization.class);
        when(mockOrgs.getOrganization()).thenReturn(mockOrg);
        given(contrastSDKMock.getProfileDefaultOrganizations()).willReturn(mockOrgs);

        assertTrue(vulnerabilityTrendRecorder.perform(build, launcher, listener));
    }

    @Test(expected = AbortException.class)
    public void testUnsuccessfulBuild() throws Exception {

        List<ThresholdCondition> conditions = new ArrayList<>();
        ThresholdCondition thresholdCondition = mock(ThresholdCondition.class);
        when(thresholdCondition.getApplicationId()).thenReturn("test");
        when(thresholdCondition.getThresholdCount()).thenReturn(0);
        when(thresholdCondition.getThresholdSeverity()).thenReturn("test");
        when(thresholdCondition.getThresholdVulnType()).thenReturn("test");
        conditions.add(thresholdCondition);

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
                "test", true, Constants.QUERY_BY_APP_VERSION_TAG_DEFAULT_FORMAT);

        Traces tracesMock = mock(Traces.class);
        when(tracesMock.getCount()).thenReturn(10);

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);

        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);
        given(VulnerabilityTrendHelper.applicationIdExists(any(ContrastSDK.class), anyString(), anyString())).willReturn(true);
        SecurityCheck undifinedPolicySecurityCheck = mock(SecurityCheck.class);
        given(undifinedPolicySecurityCheck.getResult()).willReturn(null);

        TeamServerProfile profile = mock(TeamServerProfile.class);
        given(profile.getName()).willReturn("local");
        given(profile.isAllowGlobalThresholdConditionsOverride()).willReturn(true);
        given(profile.getVulnerableBuildResult()).willReturn(Result.FAILURE.toString());
        given(profile.isFailOnWrongApplicationId()).willReturn(true);

        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profile);
        given(VulnerabilityTrendHelper.getAllTraces(any(ContrastSDK.class), anyString(), anyString(), any(TraceFilterForm.class))).willReturn(tracesMock);
        given(VulnerabilityTrendHelper.makeSecurityCheck(any(ContrastSDK.class), anyString(), anyString(), anyLong(), anyInt(), any(TraceFilterForm.class))).willReturn(undifinedPolicySecurityCheck);

        Applications applications = mock(Applications.class);
        Application application = mock(Application.class);
        when(application.getId()).thenReturn("test");
        when(application.getName()).thenReturn("test");

        when(contrastSDKMock.getApplications(anyString())).thenReturn(applications);
        when(contrastSDKMock.getTracesInOrg(anyString(), any(TraceFilterForm.class))).thenReturn(tracesMock);

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);
        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(1);

        Organizations mockOrgs = mock(Organizations.class);
        Organization mockOrg = mock(Organization.class);
        when(mockOrgs.getOrganization()).thenReturn(mockOrg);
        given(contrastSDKMock.getProfileDefaultOrganizations()).willReturn(mockOrgs);

        vulnerabilityTrendRecorder.perform(build, launcher, listener);
    }

    @Test
    public void testSuccessfulBuildWithNullCondition() throws Exception {

        List<ThresholdCondition> conditions = new ArrayList<>();
        ThresholdCondition thresholdCondition = mock(ThresholdCondition.class);
        when(thresholdCondition.getApplicationId()).thenReturn("test");
        when(thresholdCondition.getThresholdCount()).thenReturn(0);
        when(thresholdCondition.getThresholdSeverity()).thenReturn(null);
        when(thresholdCondition.getThresholdVulnType()).thenReturn(null);
        conditions.add(thresholdCondition);

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
                "test", true, Constants.QUERY_BY_APP_VERSION_TAG_DEFAULT_FORMAT);

        Traces tracesMock = mock(Traces.class);
        when(tracesMock.getCount()).thenReturn(0);

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);

        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profile = mock(TeamServerProfile.class);
        given(profile.getName()).willReturn("local");
        given(profile.isAllowGlobalThresholdConditionsOverride()).willReturn(true);
        given(profile.getVulnerableBuildResult()).willReturn(Result.FAILURE.toString());

        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profile);

        Applications applications = mock(Applications.class);
        Application application = mock(Application.class);
        when(application.getId()).thenReturn("test");
        when(application.getName()).thenReturn("test");

        when(contrastSDKMock.getApplications(anyString())).thenReturn(applications);
        when(contrastSDKMock.getTracesInOrg(anyString(), any(TraceFilterForm.class))).thenReturn(tracesMock);

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);
        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(1);

        Organizations mockOrgs = mock(Organizations.class);
        Organization mockOrg = mock(Organization.class);
        when(mockOrgs.getOrganization()).thenReturn(mockOrg);
        given(contrastSDKMock.getProfileDefaultOrganizations()).willReturn(mockOrgs);

        assertTrue(vulnerabilityTrendRecorder.perform(build, launcher, listener));
    }

    @Test
    public void testSuccessfulBuildWithAppNameAppFound() throws Exception {
        List<ThresholdCondition> conditions = new ArrayList<>();
        ThresholdCondition thresholdCondition = mock(ThresholdCondition.class);
        when(thresholdCondition.getMatchBy()).thenReturn(MatchBy.APPLICATION_ORIGIN_NAME);
        when(thresholdCondition.getThresholdCount()).thenReturn(0);
        when(thresholdCondition.getThresholdSeverity()).thenReturn(null);
        when(thresholdCondition.getThresholdVulnType()).thenReturn(null);
        when(thresholdCondition.getApplicationOriginName()).thenReturn("test");
        when(thresholdCondition.getAgentType()).thenReturn("testlang");
        when(thresholdCondition.isFailOnAppNotFound()).thenReturn(true);
        conditions.add(thresholdCondition);

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
                "test", true, Constants.QUERY_BY_APP_VERSION_TAG_DEFAULT_FORMAT);

        Traces tracesMock = mock(Traces.class);
        when(tracesMock.getCount()).thenReturn(0);

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);

        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profile = mock(TeamServerProfile.class);
        given(profile.getName()).willReturn("local");
        given(profile.isAllowGlobalThresholdConditionsOverride()).willReturn(true);
        given(profile.getVulnerableBuildResult()).willReturn(Result.FAILURE.toString());

        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profile);

        Application application = mock(Application.class);
        when(application.getId()).thenReturn("testId");

        when(contrastSDKMock.getApplicationByNameAndLanguage(anyString(), anyString(), any(AgentType.class))).thenReturn(application);

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);
        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(1);

        Organizations mockOrgs = mock(Organizations.class);
        Organization mockOrg = mock(Organization.class);
        when(mockOrgs.getOrganization()).thenReturn(mockOrg);
        given(contrastSDKMock.getProfileDefaultOrganizations()).willReturn(mockOrgs);

        assertTrue(vulnerabilityTrendRecorder.perform(build, launcher, listener));
    }

    @Test(expected = AbortException.class)
    public void testUnSuccessfulBuildAppNameAppNotFound() throws Exception {
        List<ThresholdCondition> conditions = new ArrayList<>();
        ThresholdCondition thresholdCondition = mock(ThresholdCondition.class);
        when(thresholdCondition.getMatchBy()).thenReturn(MatchBy.APPLICATION_ORIGIN_NAME);
        when(thresholdCondition.getThresholdCount()).thenReturn(0);
        when(thresholdCondition.getThresholdSeverity()).thenReturn(null);
        when(thresholdCondition.getThresholdVulnType()).thenReturn(null);
        when(thresholdCondition.getApplicationOriginName()).thenReturn("test");
        when(thresholdCondition.getAgentType()).thenReturn("testlang");
        when(thresholdCondition.isFailOnAppNotFound()).thenReturn(true);
        conditions.add(thresholdCondition);

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
                "test", true, Constants.QUERY_BY_APP_VERSION_TAG_DEFAULT_FORMAT);

        Traces tracesMock = mock(Traces.class);
        when(tracesMock.getCount()).thenReturn(0);

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);

        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profile = mock(TeamServerProfile.class);
        given(profile.getName()).willReturn("local");
        given(profile.isAllowGlobalThresholdConditionsOverride()).willReturn(true);
        given(profile.getVulnerableBuildResult()).willReturn(Result.FAILURE.toString());

        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profile);

        when(contrastSDKMock.getApplicationByNameAndLanguage(anyString(), anyString(), any(AgentType.class))).thenReturn(null); //app not found

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);
        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(1);

        Organizations mockOrgs = mock(Organizations.class);
        Organization mockOrg = mock(Organization.class);
        when(mockOrgs.getOrganization()).thenReturn(mockOrg);
        given(contrastSDKMock.getProfileDefaultOrganizations()).willReturn(mockOrgs);

        vulnerabilityTrendRecorder.perform(build, launcher, listener);

    }


    @Test
    public void testSuccessfulBuildStatusFilterEmpty() throws Exception {

        List<ThresholdCondition> conditions = new ArrayList<>();
        ThresholdCondition thresholdCondition = mock(ThresholdCondition.class);
        when(thresholdCondition.getApplicationId()).thenReturn("test");
        when(thresholdCondition.getThresholdCount()).thenReturn(0);
        when(thresholdCondition.getThresholdSeverity()).thenReturn("test");
        when(thresholdCondition.getThresholdVulnType()).thenReturn("test");
        conditions.add(thresholdCondition);

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
                "test", true, Constants.QUERY_BY_APP_VERSION_TAG_DEFAULT_FORMAT);

        final Traces tracesMock = mock(Traces.class);
        when(tracesMock.getCount()).thenReturn(0);

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);

        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profile = mock(TeamServerProfile.class);
        given(profile.getName()).willReturn("local");
        given(profile.isAllowGlobalThresholdConditionsOverride()).willReturn(true);
        given(profile.getVulnerableBuildResult()).willReturn(Result.FAILURE.toString());

        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profile);

        Applications applications = mock(Applications.class);
        Application application = mock(Application.class);
        when(application.getId()).thenReturn("test");
        when(application.getName()).thenReturn("test");

        when(contrastSDKMock.getApplications(anyString())).thenReturn(applications);
        when(contrastSDKMock.getTracesInOrg(anyString(), any(TraceFilterForm.class))).then(new Answer<Traces>() {
            public Traces answer(InvocationOnMock invocationOnMock) {
                TraceFilterForm traceFilterForm = invocationOnMock.getArgumentAt(1, TraceFilterForm.class);
                Assert.assertNull(traceFilterForm.getStatus());
                return tracesMock;
            }
        });

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);
        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(1);

        Organizations mockOrgs = mock(Organizations.class);
        Organization mockOrg = mock(Organization.class);
        when(mockOrgs.getOrganization()).thenReturn(mockOrg);
        given(contrastSDKMock.getProfileDefaultOrganizations()).willReturn(mockOrgs);

        assertTrue(vulnerabilityTrendRecorder.perform(build, launcher, listener));
    }

    @Test
    public void testSuccessfulBuildStatusFilter() throws Exception {

        List<ThresholdCondition> conditions = new ArrayList<>();
        ThresholdCondition thresholdCondition = mock(ThresholdCondition.class);
        when(thresholdCondition.getApplicationId()).thenReturn("test");
        when(thresholdCondition.getThresholdCount()).thenReturn(0);
        when(thresholdCondition.getThresholdSeverity()).thenReturn("test");
        when(thresholdCondition.getThresholdVulnType()).thenReturn("test");

        ArrayList<String> status = new ArrayList<>();
        status.add(Constants.VULNERABILITY_STATUS_AUTO_REMEDIATED);
        status.add(Constants.VULNERABILITY_STATUS_CONFIRMED);
        status.add(Constants.VULNERABILITY_STATUS_SUSPICIOUS);
        when(thresholdCondition.getVulnerabilityStatuses()).thenReturn(status);

        conditions.add(thresholdCondition);

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
                "test", true, Constants.QUERY_BY_APP_VERSION_TAG_DEFAULT_FORMAT);

        final Traces tracesMock = mock(Traces.class);
        when(tracesMock.getCount()).thenReturn(0);

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);

        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profile = mock(TeamServerProfile.class);
        given(profile.getName()).willReturn("local");
        given(profile.isAllowGlobalThresholdConditionsOverride()).willReturn(true);
        given(profile.getVulnerableBuildResult()).willReturn(Result.FAILURE.toString());

        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profile);

        Applications applications = mock(Applications.class);
        Application application = mock(Application.class);
        when(application.getId()).thenReturn("test");
        when(application.getName()).thenReturn("test");

        when(contrastSDKMock.getApplications(anyString())).thenReturn(applications);
        when(contrastSDKMock.getTracesInOrg(anyString(), any(TraceFilterForm.class))).then(new Answer<Traces>() {
            public Traces answer(InvocationOnMock invocationOnMock) {
                TraceFilterForm traceFilterForm = invocationOnMock.getArgumentAt(1, TraceFilterForm.class);
                Assert.assertNotNull(traceFilterForm.getStatus());
                Assert.assertEquals(traceFilterForm.getStatus().size(), 3);
                Assert.assertTrue(traceFilterForm.getStatus().contains(Constants.VULNERABILITY_STATUS_AUTO_REMEDIATED));
                Assert.assertTrue(traceFilterForm.getStatus().contains(Constants.VULNERABILITY_STATUS_CONFIRMED));
                Assert.assertTrue(traceFilterForm.getStatus().contains(Constants.VULNERABILITY_STATUS_SUSPICIOUS));
                return tracesMock;
            }
        });

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);
        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(1);

        Organizations mockOrgs = mock(Organizations.class);
        Organization mockOrg = mock(Organization.class);
        when(mockOrgs.getOrganization()).thenReturn(mockOrg);
        given(contrastSDKMock.getProfileDefaultOrganizations()).willReturn(mockOrgs);

        assertTrue(vulnerabilityTrendRecorder.perform(build, launcher, listener));
    }


    @Test
    public void testSuccessfulBuildAppVersionTag() throws Exception {

        List<ThresholdCondition> conditions = new ArrayList<>();
        final String appName = "WebGoat";
        final int buildNumber = 1;
        final String buildParentFullName = "Project";
        ThresholdCondition thresholdCondition = new ThresholdCondition(1, "High", "All", 0,null,
                "test", true, true, true, true, true,
                true, true, true, true);
        conditions.add(thresholdCondition);

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
                "test", true, Constants.QUERY_BY_APP_VERSION_TAG_HIERARCHICAL_FORMAT);

        when(VulnerabilityTrendHelper.buildAppVersionTagHierarchical(any(Build.class), anyString())).thenCallRealMethod();

        final Traces tracesMock = mock(Traces.class);
        when(tracesMock.getCount()).thenReturn(0);

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);

        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profile = mock(TeamServerProfile.class);
        given(profile.getName()).willReturn("local");
        given(profile.isAllowGlobalThresholdConditionsOverride()).willReturn(true);
        given(profile.getVulnerableBuildResult()).willReturn(Result.FAILURE.toString());

        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profile);

        Applications applications = mock(Applications.class);
        Application application = mock(Application.class);
        when(application.getId()).thenReturn("test");
        when(application.getName()).thenReturn("test");

        when(contrastSDKMock.getApplications(anyString())).thenReturn(applications);
        when(contrastSDKMock.getTracesInOrg(anyString(), any(TraceFilterForm.class))).then(new Answer<Traces>() {
            public Traces answer(InvocationOnMock invocationOnMock) {
                TraceFilterForm traceFilterForm = invocationOnMock.getArgumentAt(1, TraceFilterForm.class);
                Assert.assertEquals(traceFilterForm.getAppVersionTags().get(0), appName + "-" + buildParentFullName + "-" + buildNumber);
                return tracesMock;
            }
        });

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);

        AbstractProject<?, ?> parent = mock(AbstractProject.class);

        ItemGroup itemGroup = mock(ItemGroup.class);
        when(itemGroup.getFullName()).thenReturn("");
        when(parent.getParent()).thenReturn(itemGroup);

        when(parent.getFullName()).thenReturn(buildParentFullName);

        Mockito.<AbstractProject<?, ?>>when(build.getParent()).thenReturn(parent);

        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(buildNumber);

        Organizations mockOrgs = mock(Organizations.class);
        Organization mockOrg = mock(Organization.class);
        when(mockOrgs.getOrganization()).thenReturn(mockOrg);
        given(contrastSDKMock.getProfileDefaultOrganizations()).willReturn(mockOrgs);

        assertTrue(vulnerabilityTrendRecorder.perform(build, launcher, listener));
    }

    /**
     * Test that a job configured with an application that has it's thresholds overridden by a job outcome policy does not need to have a threshold configured in jenkins first.
     */
    @Test
    public void testSuccessfulJopWithoutThreshold() throws Exception{
        List<ThresholdCondition> conditions = new ArrayList<>();
        final int buildNumber = 1;
        final String buildParentFullName = "Project";

        //a condition without any thresholds
        ThresholdCondition defaultThresholdCondition = mock(ThresholdCondition.class);
        when(defaultThresholdCondition.getApplicationId()).thenReturn("test");

        conditions.add(defaultThresholdCondition);

        given(VulnerabilityTrendHelper.applicationIdExists(any(), anyString(), anyString())).willReturn(true);
        given(VulnerabilityTrendHelper.getThresholdConditions(any(), any())).willReturn(Lists.newArrayList());//simulate no global thresholds defined.

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
            "test", false, Constants.QUERY_BY_APP_VERSION_TAG_HIERARCHICAL_FORMAT);

        when(VulnerabilityTrendHelper.buildAppVersionTagHierarchical(any(Build.class), anyString())).thenCallRealMethod();

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);
        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profileMock = mock(TeamServerProfile.class);
        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profileMock);
        when(profileMock.isAllowGlobalThresholdConditionsOverride()).thenReturn(false);

        JobOutcomePolicy jobOutcomePolicyMock = mock(JobOutcomePolicy.class);
        when(jobOutcomePolicyMock.getOutcome()).thenReturn(JobOutcomePolicy.Outcome.UNSTABLE);

        SecurityCheck securityCheckMock = mock(SecurityCheck.class);
        when(VulnerabilityTrendHelper.makeSecurityCheck(any(), anyString(), anyString(), anyLong(), anyInt(), any(TraceFilterForm.class))).thenReturn(securityCheckMock);
        when(securityCheckMock.getResult()).thenReturn(false);
        when(securityCheckMock.getJobOutcomePolicy()).thenReturn(jobOutcomePolicyMock);

        when(VulnerabilityTrendHelper.getJenkinsResultFromJobOutcome(any())).thenReturn(Result.UNSTABLE);

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);

        AbstractProject<?, ?> parent = mock(AbstractProject.class);

        ItemGroup itemGroup = mock(ItemGroup.class);
        when(itemGroup.getFullName()).thenReturn("");
        when(parent.getParent()).thenReturn(itemGroup);

        when(parent.getFullName()).thenReturn(buildParentFullName);

        Mockito.<AbstractProject<?, ?>>when(build.getParent()).thenReturn(parent);

        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(buildNumber);

        Organizations mockOrgs = mock(Organizations.class);
        Organization mockOrg = mock(Organization.class);
        when(mockOrgs.getOrganization()).thenReturn(mockOrg);
        given(contrastSDKMock.getProfileDefaultOrganizations()).willReturn(mockOrgs);

        assertTrue(vulnerabilityTrendRecorder.perform(build, launcher, listener));
    }

    /**
     * Test that a job configured with an application without any applicable job outcome policies sets the outcome of a vulnerable build when the checkbox is checked.
     */
    @Test
    public void testFailNonJopWithoutThreshold_checked() throws Exception{
        List<ThresholdCondition> conditions = new ArrayList<>();
        final int buildNumber = 1;
        final String buildParentFullName = "Project";

        //a condition without any thresholds
        ThresholdCondition defaultThresholdCondition = mock(ThresholdCondition.class);
        when(defaultThresholdCondition.getApplicationId()).thenReturn("test");

        conditions.add(defaultThresholdCondition);

        given(VulnerabilityTrendHelper.applicationIdExists(any(), anyString(), anyString())).willReturn(true);
        given(VulnerabilityTrendHelper.getThresholdConditions(any(), any())).willReturn(Lists.newArrayList());//simulate no global thresholds defined.

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
            "test", false, Constants.QUERY_BY_APP_VERSION_TAG_HIERARCHICAL_FORMAT);

        when(VulnerabilityTrendHelper.buildAppVersionTagHierarchical(any(Build.class), anyString())).thenCallRealMethod();

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);
        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profileMock = mock(TeamServerProfile.class);
        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profileMock);
        when(profileMock.isAllowGlobalThresholdConditionsOverride()).thenReturn(false);
        when(profileMock.isApplyVulnerableBuildResultOnContrastError()).thenReturn(true);
        when(profileMock.getVulnerableBuildResult()).thenReturn(Result.UNSTABLE.toString());

        SecurityCheck securityCheckMock = mock(SecurityCheck.class);
        when(VulnerabilityTrendHelper.makeSecurityCheck(any(), anyString(), anyString(), anyLong(), anyInt(), any(TraceFilterForm.class))).thenReturn(securityCheckMock);
        when(securityCheckMock.getResult()).thenReturn(null);

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);

        AbstractProject<?, ?> parent = mock(AbstractProject.class);

        ItemGroup itemGroup = mock(ItemGroup.class);
        when(itemGroup.getFullName()).thenReturn("");
        when(parent.getParent()).thenReturn(itemGroup);

        when(parent.getFullName()).thenReturn(buildParentFullName);

        Mockito.<AbstractProject<?, ?>>when(build.getParent()).thenReturn(parent);

        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(buildNumber);

        Organizations mockOrgs = mock(Organizations.class);
        Organization mockOrg = mock(Organization.class);
        when(mockOrgs.getOrganization()).thenReturn(mockOrg);
        given(contrastSDKMock.getProfileDefaultOrganizations()).willReturn(mockOrgs);

        vulnerabilityTrendRecorder.perform(build, launcher, listener);
        verify(build).setResult(Result.fromString(profileMock.getVulnerableBuildResult()));
    }

    /**
     * Test that a job configured with an application without any applicable job outcome policies does not set the outcome of a vulnerable build when the checkbox is not checked.
     */
    @Test
    public void testFailNonJopWithoutThreshold_unchecked() throws Exception{
        List<ThresholdCondition> conditions = new ArrayList<>();
        final int buildNumber = 1;
        final String buildParentFullName = "Project";

        //a condition without any thresholds
        ThresholdCondition defaultThresholdCondition = mock(ThresholdCondition.class);
        when(defaultThresholdCondition.getApplicationId()).thenReturn("test");

        conditions.add(defaultThresholdCondition);

        given(VulnerabilityTrendHelper.applicationIdExists(any(), anyString(), anyString())).willReturn(true);
        given(VulnerabilityTrendHelper.getThresholdConditions(any(), any())).willReturn(Lists.newArrayList());//simulate no global thresholds defined.

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
            "test", false, Constants.QUERY_BY_APP_VERSION_TAG_HIERARCHICAL_FORMAT);

        when(VulnerabilityTrendHelper.buildAppVersionTagHierarchical(any(Build.class), anyString())).thenCallRealMethod();

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);
        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profileMock = mock(TeamServerProfile.class);
        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profileMock);
        when(profileMock.isAllowGlobalThresholdConditionsOverride()).thenReturn(false);
        when(profileMock.isApplyVulnerableBuildResultOnContrastError()).thenReturn(false);
        when(profileMock.getVulnerableBuildResult()).thenReturn(Result.UNSTABLE.toString());

        List<Trace> traceList = new ArrayList<>();
        Traces tracesMock = mock(Traces.class);
        when(tracesMock.getTraces()).thenReturn(traceList);

        given(VulnerabilityTrendHelper.getAllTraces(any(ContrastSDK.class), anyString(), anyString(), any(TraceFilterForm.class))).willReturn(tracesMock);

        SecurityCheck securityCheckMock = mock(SecurityCheck.class);
        when(VulnerabilityTrendHelper.makeSecurityCheck(any(), anyString(), anyString(), anyLong(), anyInt(), any(TraceFilterForm.class))).thenReturn(securityCheckMock);
        when(securityCheckMock.getResult()).thenReturn(null);

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);

        AbstractProject<?, ?> parent = mock(AbstractProject.class);

        ItemGroup itemGroup = mock(ItemGroup.class);
        when(itemGroup.getFullName()).thenReturn("");
        when(parent.getParent()).thenReturn(itemGroup);

        when(parent.getFullName()).thenReturn(buildParentFullName);

        Mockito.<AbstractProject<?, ?>>when(build.getParent()).thenReturn(parent);

        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(buildNumber);

        Organizations mockOrgs = mock(Organizations.class);
        Organization mockOrg = mock(Organization.class);
        when(mockOrgs.getOrganization()).thenReturn(mockOrg);
        given(contrastSDKMock.getProfileDefaultOrganizations()).willReturn(mockOrgs);

        vulnerabilityTrendRecorder.perform(build, launcher, listener);
        verify(build, never()).setResult(Result.fromString(profileMock.getVulnerableBuildResult()));
    }

    @Test
    public void testGlobalThresholdUsedWhenNotOverridden()
        throws IOException, UnauthorizedException, InterruptedException {
        List<ThresholdCondition> conditions = new ArrayList<>();
        final int buildNumber = 1;
        final String buildParentFullName = "Project";

        //a condition without any thresholds
        ThresholdCondition defaultThresholdCondition = mock(ThresholdCondition.class);
        when(defaultThresholdCondition.getApplicationId()).thenReturn("test");

        conditions.add(defaultThresholdCondition);

        //a global condition
        GlobalThresholdCondition globalThresholdCondition = mock(GlobalThresholdCondition.class);
        List<GlobalThresholdCondition> globalThresholdConditions = new ArrayList<>();
        globalThresholdConditions.add(globalThresholdCondition);

        given(VulnerabilityTrendHelper.getGlobalThresholdConditions(anyString())).willReturn(globalThresholdConditions);


        given(VulnerabilityTrendHelper.applicationIdExists(any(), anyString(), anyString())).willReturn(true);
        given(VulnerabilityTrendHelper.getThresholdConditions(conditions, globalThresholdConditions)).willReturn(Lists.newArrayList());

        VulnerabilityTrendRecorder vulnerabilityTrendRecorder = new VulnerabilityTrendRecorder(conditions,
            "test", false, Constants.QUERY_BY_APP_VERSION_TAG_HIERARCHICAL_FORMAT);

        when(VulnerabilityTrendHelper.buildAppVersionTagHierarchical(any(Build.class), anyString())).thenCallRealMethod();

        ContrastSDK contrastSDKMock = mock(ContrastSDK.class);
        given(VulnerabilityTrendHelper.createSDK(anyString(), anyString(), anyString(), anyString())).willReturn(contrastSDKMock);

        TeamServerProfile profileMock = mock(TeamServerProfile.class);
        given(VulnerabilityTrendHelper.getProfile(anyString())).willReturn(profileMock);
        when(profileMock.isAllowGlobalThresholdConditionsOverride()).thenReturn(false);
        when(profileMock.isApplyVulnerableBuildResultOnContrastError()).thenReturn(true);
        when(profileMock.getVulnerableBuildResult()).thenReturn(Result.UNSTABLE.toString());

        SecurityCheck securityCheckMock = mock(SecurityCheck.class);
        when(VulnerabilityTrendHelper.makeSecurityCheck(any(), anyString(), anyString(), anyLong(), anyInt(), any(TraceFilterForm.class))).thenReturn(securityCheckMock);
        when(securityCheckMock.getResult()).thenReturn(null);

        AbstractBuild<?, ?> build = mock(AbstractBuild.class);

        AbstractProject<?, ?> parent = mock(AbstractProject.class);

        ItemGroup itemGroup = mock(ItemGroup.class);
        when(itemGroup.getFullName()).thenReturn("");
        when(parent.getParent()).thenReturn(itemGroup);

        when(parent.getFullName()).thenReturn(buildParentFullName);

        Mockito.<AbstractProject<?, ?>>when(build.getParent()).thenReturn(parent);

        Launcher launcher = mock(Launcher.class);
        BuildListener listener = mock(BuildListener.class);

        when(build.isBuilding()).thenReturn(true);
        when(build.getNumber()).thenReturn(buildNumber);

        Organizations mockOrgs = mock(Organizations.class);
        Organization mockOrg = mock(Organization.class);
        when(mockOrgs.getOrganization()).thenReturn(mockOrg);
        given(contrastSDKMock.getProfileDefaultOrganizations()).willReturn(mockOrgs);

        vulnerabilityTrendRecorder.perform(build, launcher, listener);
        verifyStatic();
        VulnerabilityTrendHelper.getThresholdConditions(conditions, globalThresholdConditions);
    }

}